  به نام خدا 

امیرمهدی رضائی + GroK / کد دانشجویی ۴۰۳۱۰۳۱۱۰ / کد ملی ۰۳۷۳۰۱۱۲۳۷

https://github.com/AmirMahdiRezaeiEECS/thesis-project-introduction-to-Multi-Agent-AI-medels-

![Uploading Screenshot 1404-06-26 at 1.42.00 AM.png…]()


توجه : داکیومنت زیر بر اساس اصول مهندسی پرامپت ،‌برای همکاری با LLMs بهینه شده است . به همین علت ساختاری کمی متفاوت از داکیومنت های قدیمی و مرسوم دارد.  

## شرح پروژه پایتون: "سیستم مدیریت پایان‌نامه‌ها"

پروژه ما "طراحی و پیاده‌سازی یک سامانه برای مدیریت فرآیند پایان‌نامه‌ها" است. هدف از این پروژه، ایجاد یک **سیستم جامع و کاربردی** است که تمام مراحل یک پایان‌نامه، از آغاز روند اخذ درس پایان‌نامه تا ارزیابی نهایی را مدیریت کند.

**فعلا برای ساخت نسخه اول، فقط یک نسخه حداقلی (Minimum Viable Product) که کامل باشه و کار کنه خواهیم ساخت و بخش‌های کم‌اهمیت که به کارکرد کلی برنامه آسیبی نمی‌زنن، به نسخه دوم واگذار خواهند شد.**

### 📌 نکات و الزامات

- **مدیریت کاربران سامانه شامل ثبت یا ویرایش اطلاعات دانشجو و استاد نیست، بانک اطلاعاتی این کاربران را به‌صورت دستی در فایل مربوطه تکمیل خواهیم کرد.**
- **برای ذخیره داده باید از فرمت داده JSON استفاده کرد، کلیه فایل‌های دیگر نیز (PDF، تصاویر و ...) باید در فولدر مربوطه ذخیره شود و مسیر آن‌ها در صورت نیاز در فایل‌های JSON جایگذاری شوند.**
- **اصل ماژولار بودن و شیءگرایی رعایت شود.**

## زبان و ابزارها

- **زبان برنامه‌نویسی**: Python
- **دیتابیس**: فایل‌های JSON
- **محیط کاربری**: Command Line Interface (CLI)
- **ذخیره‌ی فایل‌ها**: PDF، JPG در پوشه‌های مربوطه، مسیرشان در JSON نگهداری می‌شود.

### تعریف عملکردها و بخش‌های اصلی سیستم

#### سامانه باید از دو بخش اصلی تشکیل شود: بخش دانشجو و بخش استاد.

- **دانشجویان و اساتید از قبل در سیستم ذخیره شده‌اند.**
- **برای هر استاد دروس آن تعریف شده است.**

پایان‌نامه در قالب یک درس توسط دانشجو اخذ می‌گردد و پایان‌نامه با اساتید مختلف ارائه می‌شود. اطلاعات درس‌ها در سامانه به‌صورت زیر باید مدیریت شود:
- **آید‌ی (یونیک)**
- **عنوان**
- **استاد**
- **سال**
- **نیمسال (نیمسال اول/دوم)**
- **ظرفیت**
- **منابع درسی**
- **تعداد جلسات**
- **واحد**

#### ۱. بخش دانشجو

این بخش برای مدیریت فعالیت‌های دانشجو در فرآیند پایان‌نامه است و شامل قابلیت‌های زیر است:

##### ۱. ورود
دانشجو باید بتواند با **کد دانشجویی و رمز عبور** وارد سیستم شود.

##### ۲. درخواست اخذ درس پایان‌نامه
دانشجو باید بتواند درخواست اخذ پایان‌نامه را از بین درس‌های دارای ظرفیت ثبت نماید.

##### ۳. مشاهده وضعیت درس پایان‌نامه
دانشجو باید بتواند وضعیت درخواست اخذ خود را مشاهده کند ("در انتظار تأیید استاد"، "تأیید شده"، "رد شده"). **در نسخه اولیه برنامه، این صرفا نمای این بخش را می‌سازیم. یعنی در نسخه اولیه برنامه ما، درخواست‌ها همه تأیید شده‌اند و نیاز به درخواست از استاد و گرفتن تأیید ندارند. اما در نسخه‌های بعد این بخش از حالت نمایشی به حالت واقعی تغییر خواهد کرد. یعنی واقعا باید درخواست ثبت شود و منتظر تأیید استاد بمانیم.**

##### ۴. ارسال مجدد درخواست اخذ درس پایان‌نامه
در صورت رد شدن درخواست توسط استاد، دانشجو باید امکان درخواست مجدد برای اخذ درس پایان‌نامه را داشته باشد. **(این بخش هم در نسخه اول فقط نما است و در نسخه‌های بعد تکمیل می‌شود. پس برای نسخه اول، فقط نمایی از این بخش را خواهیم ساخت و عملکردش را به نسخه‌های بعد موکول خواهیم کرد.)**

##### ۵. ارسال درخواست دفاع
در صورت تأیید شدن درخواست اخذ پایان‌نامه، دانشجو باید بتواند درخواست دفاع دهد. ثبت درخواست دفاع شامل ثبت فایل‌های نهایی می‌باشد. **(در نسخه اول برنامه، نیازی به تأیید استاد نیست اما در نسخه دوم، درخواست دفاع نیز جهت نهایی شدن نیازمند تأیید استاد راهنما، انتخاب تاریخ دفاع و داوران توسط استاد است، پس دانشجو باید بتواند وضعیت درخواست خود را ببیند و استاد نیز باید بتواند درخواست‌های دفاع ارسالی برای خود را مدیریت نماید.)**

مواردی که درج آن برای پایان‌نامه ضروری است:
- **عنوان**
- **نویسنده**
- **سال/نیمسال**
- **داوران**
- **استاد راهنما**
- **فایل PDF شامل متن پایان‌نامه**
- **نتیجه‌ی دفاع: دفاع/دفاع مجدد**
- **کلمات کلیدی (برای اینکه بعدا موتور جست‌وجوی برنامه بتونه سرچ کنه)**

##### ۶. جستجوی در بانک پایان‌نامه‌ها
**کلیه کاربران اعم از دانشجویان یا اساتید باید بتوانند در آرشیو پایان‌نامه‌های قبلی (پایان‌نامه‌های دفاع‌شده و مختومه) جستجو کنند.**

#### ۲. بخش استاد

این بخش برای مدیریت فرآیندهای مربوط به پایان‌نامه‌های دانشجویان توسط استاد است و شامل قابلیت‌های زیر می‌شود:

##### ۱. ورود
استاد باید بتواند با **کد استادی و رمز عبور** خود وارد شود.

##### ۲. بخش استاد راهنما
###### مشاهده، بررسی و تأیید لیست درخواست‌های اخذ پایان‌نامه
استاد باید بتواند لیست درخواست‌های دانشجویان برای انتخاب پایان‌نامه با خود را ببیند همچنین باید بتواند درخواست‌های دانشجویان را بررسی کرده و آن‌ها را **"تأیید" یا "رد"** کند.  
**نکته: در نسخه‌های بعدی، هر استاد ۵ ظرفیت برای استاد راهنمایی و ۱۰ ظرفیت برای داوری دارد. اما در نسخه اولیه محدودیتی وجود ندارد.**

###### مشاهده فایل و اطلاعات پایان‌نامه
استاد باید بتواند فایل و اطلاعات پایان‌نامه دانشجو را بررسی کند.

###### تأیید و مدیریت درخواست‌های دفاع ارسالی
**در نسخه‌های بعدی برنامه، تاریخ دفاع و داورها (یک داور داخلی و یک داور خارجی) توسط استاد راهنما انتخاب می‌شود (این موارد به معنی تأیید آغاز فرآیند دفاع است در غیر این صورت راهنما باید بتواند درخواست دفاع را رد کند). این بخش باید در نسخه اولیه برنامه نیز ساخته شود.**  
**(در نسخه‌های بعدی برنامه، پس از گذشت سه ماه از تأیید اخذ پایان‌نامه، اجازه اعلام آمادگی دانشجو برای جلسه دفاع صادر می‌شود. اما در نسخه اولیه، چنین محدودیتی وجود ندارد و دانشجو هر زمان بعد از تأیید اخذ پایان‌نامه، می‌تواند برای جلسه دفاع درخواست دهد. نکته: پس از ثبت نمره توسط داوران عملا فرآیند دفاع به اتمام رسیده و ظرفیت استاد برای استاد راهنما یا داوری (بسته به موقعیت آن) باید باز شود.)**

###### بخش داور
اساتید می‌توانند داوری پایان‌نامه‌ها را نیز بر عهده بگیرند.  
در این بخش در نظر بگیرید که استاد راهنما خارج از سامانه مراتب هماهنگی با داوران را انجام می‌دهد (نیازی به ساخت بخش‌های هماهنگی بین داوران و اساتید و ... نیست) و با انتخاب داور دیگر نیازی به تأیید داور نیست و داور صرفا پس از برگزاری جلسه دفاع (پس از تاریخ دفاع ثبت‌شده)، باید بتوانند نمره پایان‌نامه را ثبت نمایند.

###### جستجو در بانک پایان‌نامه‌ها
**کلیه کاربران اعم از دانشجویان یا اساتید باید بتوانند در آرشیو پایان‌نامه‌های قبلی (پایان‌نامه‌های دفاع‌شده و مختومه) جستجو کنند.**

#### ۳. موتور جست‌وجو
**همان‌طور که پیشتر گفته شد، موتور جست‌وجوی مورد استفاده اساتید و دانشجویان یکسان است و نتیجه جستجو باید در قالب اطلاعات زیر نمایش یابد:**
- **عنوان**
- **نویسنده**
- **سال/نیمسال**
- **داوران**
- **استاد راهنما**
- **لینک دانلود فایل**

## روش برنامه‌نویسی ما

من دانش و تجربه زیادی در پایتون ندارم. کمی پایتون بلدم و کمی OOP بلدم اما در عین حال، پروژه سختی در پیش دارم. پس باید از اصول زیر پیروی کنیم:

### سادگی + قابلیت نگهداری و توسعه بالا
با توجه به اینکه من برنامه‌نویس حرفه‌ای نیستم، باید از کدهای ساده استفاده کنیم اما کدها رو به شکلی قابل نگهداری و توسعه بنویسیم که قابلیت نگهداری و توسعه داشته باشند.

### شیءگرایی و ماژولاریتی
**مهم‌ترین مسئله در روش برنامه‌نویسی ما، شیءگرایی و ماژولاریتی برنامه است. این برای من خیلی خیلی مهمه. باید یک کتابخانه یا پکیج بنویسیم که کلاس‌ها، توابع و ... که قراره در کد اصلی‌مون استفاده کنیم رو اونجا بسازیم. چون می‌خواهم کد اصلی خیلی تمیز و مختصر باشه و پیچیدگی‌های کد در یک جا متمرکز نشه؛ پس باید هر بخش رو ساده طراحی کنیم و از کنار هم قرار دادن بخش‌های ساده (با استفاده از ماژول‌هایی که نوشتیم)، بخش‌های پیچیده‌تر رو بسازیم.**

### نسخه اولیه حداقلی قابل نگهداری و توسعه
**نسخه‌های اولیه برنامه باید ساده و حداقلی باشد. بخش‌هایی از برنامه که به عملکرد کلی برنامه صدمه وارد نمی‌کنند ناقص باقی بمانند اما به شکلی ماژولار و قابل توسعه نوشته شوند که در نسخه‌های بعدی قابلیت کامل کردن داشته باشند. در عین حال، بخش‌های اصلی برنامه باید کامل باشند عملکرد کلی برنامه باید حتی در اولین نسخه، تضمین شود. یعنی اگر چه برخی بخش‌ها ناقص هستند اما برنامه باید به‌طور کامل اجرا شود.**

بعد از ساخت نسخه اولیه، نسخه به نسخه، بخش‌های ناقص اسکلت اولیه را کامل خواهیم کرد.

#### هشدار: ساختار کلی و عملکرد نسخه‌های حداقلی نیز باید کامل باشد
**حداقلی بودن کد و ناقص گذاشتن برخی بخش‌ها، به معنای ناقص بودن ساختار نیست. حتی اگر پوشه بعضی قسمت‌های ساختار الان خالی بمونن، باید ساختار کلی برنامه رو اصولی جلو ببریم که بعدا در نسخه‌های بعد قابلیت کامل شدن و گسترش داشته باشه.**  
**علاوه بر کامل بودن ساختار، عملکرد کلی برنامه نیز باید کامل باشه.**

### نوشتن شبه‌کد (Pseudocode) قبل از نوشتن کد اصلی و در طول توسعه
برای تمام بخش‌های برنامه از جمله ماژول‌ها، قبل از کدنویسی، گام به گام و با مشورت هم، شبه‌کد برنامه رو بنویسیم، بعد از توافق روی اجزا برنامه، شروع به کدنویسی خواهیم کرد.  
**نوشتن شبه‌کد به ما کمک می‌کنه که بدون درگیری با syntax، روی جزئیات برنامه‌مون کار کنیم و بخش‌های مبهم رو شفاف کنیم و تصمیمات لازم رو قبل از درگیری با syntax بگیریم.**  
شبه‌کدها، بخش مهمی از برنامه‌اند. پس اون‌ها رو هم مثل کد اصلی، در قالب داکیومنت، نگهداری می‌کنیم و توسعه می‌دیم.  
**ساختار شبه‌کدها هم باید مطابق ساختار کد، ماژولار و بر اساس شیءگرایی باشه و حتی نگهداری شبه‌کدها هم در ساختاری منظم انجام بشه. انگار که واقعا داریم برنامه رو می‌نویسیم.**

### توسعه گام به گام
**باید گام به گام و با گام‌هایی کوچک جلو بریم. گام‌هایی کوچک و حداقلی که همگی باید با مشورت من انجام شوند.**

### تست‌های گام به گام
**بعد از هر گام، باید عملکرد بخش نوشته‌شده را تست کنیم.** من تست‌های کوچک را به تست‌های جامع ترجیح می‌دم. در نهایت بعد از اینکه تست‌های کوچک انجام شد و گام به گام جلو رفتیم، تست‌های جامع‌تر نیز انجام خواهیم داد.

### توسعه نسخه به نسخه محافظه‌کارانه
در حین ساخت نسخه حداقلی اول، انتقادات، پیشنهادات و برنامه‌مون برای ساخت نسخه‌های آینده رو داکیومنت خواهیم کرد.  
بعد از پایان توسعه ورژن حداقلی (اما با عملکرد صحیح) و انجام تست‌های لازم و راضی بودن از نتیجه، نوبت به توسعه بیشتر سیستم خواهد رسید. در این مرحله هم محافظه‌کارانه جلو خواهیم رفت و تمام تغییرات و پیشرفت‌های دلخواهمون رو در یک مرحله پیاده‌سازی نخواهیم کرد. بلکه ورژن به ورژن، با گام‌هایی کوچک، در هر نسخه، بهبودهایی ایجاد می‌کنیم یا برنامه رو گسترش می‌دیم. بعد از تست کردن تغییرات و راضی بودن از عملکرد، به سراغ نسخه‌های بعدی و بعدی خواهیم رفت.

## شروع مسیر برنامه‌نویسی

**گام به گام جلو بریم. بدون مشورت کردن با من نباید کاری انجام بشه. هر کاری هم که می‌خوای انجام بدی باید توضیح بدی. من نظرات، پیشنهادات، اهداف و برنامه‌ام رو شرح دادم. هر جا که به نظرت مبهمه، می‌تونیم صحبت کنیم.**  
می‌تونیم روی شبه‌کد مشورت کنیم، اسکلت اولیه پروژه رو شکل بدیم و ماژول‌ها، فایل‌ها و ساختار کلی برنامه رو اصلاح کنیم و ... . اصلاح و مشورت خوبه اما خودسر حق نداری هیچ کدوم از این‌ها رو تغییر بدی.

### بخش اول: اسکلت اولیه و ساختار کلی برنامه

```
.

├── data

│   ├── courses.json

│   ├── defended_thesis.json

│   ├── professors.json

│   ├── students.json

│   ├── thesis.json

│   └── uploads

│       └── test.pdf

├── history

│   └── changelog.txt

├── main_program.py

├── pytest.ini

├── README.md

├── src

│   ├──  __init__.py

│   ├── entities

│   │   ├──  __init__.py

│   │   ├── __pycache__

│   │   │   ├── course.cpython-311.pyc

│   │   │   ├── defense.cpython-311.pyc

│   │   │   ├── professor.cpython-311.pyc

│   │   │   ├── student.cpython-311.pyc

│   │   │   ├── thesis.cpython-311.pyc

│   │   │   └── user.cpython-311.pyc

│   │   ├── course.py

│   │   ├── defense.py

│   │   ├── professor.py

│   │   ├── README.md

│   │   ├── student.py

│   │   ├── thesis.py

│   │   └── user.py

│   ├── interfaces

│   │   ├──  __init__.py

│   │   ├── __pycache__

│   │   │   ├── auth.cpython-311.pyc

│   │   │   ├── professor_menu.cpython-311.pyc

│   │   │   ├── student_menu.cpython-311.pyc

│   │   │   └── welcome.cpython-311.pyc

│   │   ├── auth.py

│   │   ├── professor_menu.py

│   │   ├── README.md

│   │   ├── student_menu.py

│   │   └── welcome.py

│   ├── search

│   │   ├──  __init__.py

│   │   └── search_engine.py

│   ├── storage

│   │   ├──  __init__.py

│   │   ├── __pycache__

│   │   │   └── json_storage.cpython-311.pyc

│   │   ├── file_manager.py

│   │   └── json_storage.py

│   ├── utilities

│   │   ├──  __init__.py

│   │   └── utils.py

│   └── workflow

│       ├──  __init__.py

│       └── thesis_workflow.py

└── tests

    ├──  __init__.py

    ├── __pycache__

    │   ├── test_auth.cpython-311-pytest-7.4.0.pyc

    │   ├── test_comprehensive.cpython-311-pytest-7.4.0.pyc

    │   ├── test_entities.cpython-311-pytest-7.4.0.pyc

    │   ├── test_json_storage.cpython-311-pytest-7.4.0.pyc

    │   ├── test_json_storage.cpython-311.pyc

    │   ├── test_main.cpython-311-pytest-7.4.0.pyc

    │   ├── test_menus.cpython-311-pytest-7.4.0.pyc

    │   ├── test_search.cpython-311-pytest-7.4.0.pyc

    │   └── test_workflow.cpython-311-pytest-7.4.0.pyc

    ├── test_auth.py

    ├── test_comprehensive.py

    ├── test_entities.py

    ├── test_json_storage.py

    ├── test_main.py

    ├── test_menus.py

    ├── test_search.py

    └── test_workflow.py
```

موارد فوق بر اساس OOP و برنامه‌نویسی ماژولار طراحی خواهند شد.

### بخش دوم: فایل‌های JSON و ارتباطشان با برخی کلاس‌ها

من کار با فایل‌های JSON رو بلد نیستم. در این مرحله، علاوه بر انجام پروژه، باید کار با این فایل‌ها رو هم آموزش ببینم .

1) **students.json**  
   **هدف**: نگهداری اطلاعات دانشجویان  
   **فیلدها**:  
   - **name**: نام کامل دانشجو  
   - **student_code**: کد دانشجویی برای ورود  
   - **password**: رمز عبور  

2) **professors.json**  
   **هدف**: نگهداری اطلاعات اساتید  
   **فیلدها**:  
   - **name**: نام استاد  
   - **teacher_code**: کد ورود استاد  
   - **password**: رمز عبور  
   - **capacity_supervise**: تعداد دانشجوی قابل راهنمایی (اختیاری)  
   - **capacity_judge**: تعداد پایان‌نامه قابل داوری (اختیاری)  

3) **courses.json**  
   **هدف**: نگهداری اطلاعات درس‌ها  
   **فیلدها**:  
   - **course_title**: عنوان درس  
   - **ID**: آیدی درس  
   - **professor_code**: استاد درس  
   - **year**: سال تحصیلی  
   - **semester**: نیمسال (اول یا دوم)  
   - **capacity**: تعداد دانشجویان مجاز  
   - **resources**: منابع درس  
   - **sessions**: تعداد جلسات  
   - **unit**: تعداد واحد  

4) **thesis.json**  
   **هدف**: ذخیره درخواست‌های اخذ درس پایان‌نامه توسط دانشجو  
   **فیلدها**:  
   - **student_code**: کد دانشجو  
   - **course_ID**: آیدی درس اخذشده  
   - **request_date**: تاریخ ثبت درخواست  
   - **approval_date**: تاریخ تأیید توسط استاد (در صورت تأیید)  
   - **status**: وضعیت درخواست (در انتظار تأیید استاد، تأیید شده، رد شده)  
   **روش دیگر**:  
   - **student_code**: کد دانشجوی اخذکننده درس  
   - **course_ID**: آیدی درس برای پایان‌نامه اخذشده  
   - **status**: وضعیت درخواست (در انتظار تأیید استاد، تأیید شده، رد شده، در دفاع)  
   - **request_date**: تاریخ ثبت درخواست  
   - **defense_date**: تاریخ دفاع (در صورت تأیید استاد)  
   - **files**: مسیر فایل‌های PDF و تصاویر  
   - **score**: نمره (بعد از دفاع)  
   - **judges**: لیست داوران انتخابی توسط استاد  
   **نکته**: شناسه یکتا پایان‌نامه نداریم! شناسایی با ترکیب `student_code` + `course_ID` انجام می‌شود.

5) **defended_thesis.json**  
   **هدف**: آرشیو پایان‌نامه‌های دفاع‌شده و ثبت نمره و فایل‌ها  
   **فیلدها**:  
   - **student_code**: کد دانشجو  
   - **course_ID**: درس اخذشده برای پایان‌نامه  
   - **title**: عنوان پایان‌نامه  
   - **year**: سال دفاع  
   - **semester**: نیمسال دفاع  
   - **supervisor**: استاد راهنما  
   - **judges**: داوران  
   - **score**: نمره نهایی  
   - **files**: مسیر فایل‌های PDF و تصاویر  
   **نکته**: همه اطلاعات مربوط به دفاع، فایل‌ها و نمره نهایی در این فایل ذخیره می‌شوند.

#### هشدار
- **از سخت‌کُد کردن داده‌ها اجتناب کن.**
- **پروژه باید portable باشه.**
- **اصل Single Source of Truth رعایت شود.**

#### مدیریت فایل‌ها
- **برای ذخیره داده باید از فرمت داده JSON استفاده کرد، کلیه فایل‌های دیگر نیز (PDF، تصاویر و ...) باید در فولدر مربوطه ذخیره شود و مسیر آن‌ها در صورت نیاز در فایل‌های JSON جایگذاری شوند.**  
- **نکته مهم: نام فایل‌ها شامل `student_code` و `course_title` باشد تا یکتا شوند.**

### بخش سوم: توسعه (MVP و پکیج اصلی + پکیج سطح پایین)

در بخش اول به ساخت **MVP** خواهیم پرداخت. منظور از **MVP (Minimum Viable Product)** یک **نسخه حداقلی و کاربردی** از کل برنامه است که:
- باید **قابل اجرا و عملیاتی** باشد (نه فقط یک سری ماژول خام).
- دارای ساختاری **آینده‌نگرانه و قابل توسعه** باشد.
- هرچند بسیاری از بخش‌ها هنوز کامل نشده‌اند، اما در همین نسخه باید برنامه به‌طور کامل کار کند.

در گام اول این مرحله، باید تعیین کنیم که چه بخش‌هایی رو تا چه حد پیش خواهیم رفت، چگونه انجامش خواهیم داد. همچنین تعیین کنیم که چه بخش‌هایی به نسخه‌های بعد موکول خواهد شد.

#### ویژگی‌های کلیدی MVP
حتی اولین نسخه حداقلی (MVP) نیز باید:
- **کدی تمیز و خوانا** داشته باشد.
- دارای **کامنت‌گذاری درست و توضیحات شفاف** باشد.
- **ساختاری آینده‌نگرانه** داشته باشد، یعنی طوری طراحی شود که توسعه در نسخه‌های بعدی بدون بازنویسی کامل امکان‌پذیر باشد.
- شامل فایل‌ها و پوشه‌هایی باشد که بعضی از آن‌ها ممکن است در این مرحله خالی بمانند، اما جایگاهشان از همین ابتدا مشخص است.

**مهم است که تأکید کنیم: MVP صرفاً یک اسکلت ناقص نیست؛ بلکه یک نسخه واقعی و کاربردی از برنامه است که می‌تواند اجرا شود و نیازهای پایه‌ای را برطرف کند.**  
**یک کد قابل استفاده اما بدون اسکلت‌بندی هم نیست. اتفاقا توجه ویژه‌ای به اسکلت قابل رشد و توسعه دارد.**

#### اصول طراحی در MVP
به‌طور خلاصه MVP ما باید از نظر امکانات، پیچیدگی و تعداد خطوط کد، حداقلی باشد در عین حال عملکرد کامل داشته باشد (گرچه با امکانات کم) اما قابل توسعه و ساختارمند باشد و اسکلت قوی داشته باشد. برای اینکه MVP هم **کار کند** و هم **قابل توسعه** باشد، از **برنامه‌نویسی شی‌گرا (OOP)** و **طراحی ماژولار** استفاده خواهیم کرد و قبل از نوشتن `main_program`، به ساخت پکیج‌های لازم خواهیم پرداخت.

- **بخش‌ها باید تا جای ممکن تک‌وظیفه‌ای طراحی شوند.** (حتی اگر یک ماژول وظیفه پیچیده‌ای داره باید حداقلی و کوچک بنویسیمش!! این کار رو با این استراتژی انجام خواهیم داد: وظیفه اصلی رو به بخش‌های کوچکتر تقسیم می‌کنیم و برای هر کدام از این بخش‌ها، یک ماژول می‌سازیم، با این کار می‌تونیم ماژول پیچیده رو ساده کنیم و به جای اینکه یک کد طولانی بنویسیم، از ماژول‌هایی که ساختیم برای ساخت این ماژول پیچیده‌تر استفاده کنیم. مثلا چند تابع رو صدا بزنیم. به‌طور کلی سعی ما بر اینه که بخش‌ها کوچک و تک‌وظیفه‌ای باشند یا حداقل وظایف رو داشته باشند. در عوض برای اجرا قسمت‌های پیچیده، یک تابع می‌تونه توابع دیگه رو صدا بزنه و ...)
- **ماژول‌ها باید کوچک و قابل تست باشند. قابل تست بودن هم مهمه. حتی اگر تست ننویسیم.**
- این MVP باید علاوه بر داشتن **پکیج‌ها**، یک **برنامه اصلی (Main Program / Application Layer)** هم داشته باشد که از این پکیج استفاده کرده و خروجی عملی و قابل مشاهده تولید کند.

#### ساختار MVP
MVP شامل سه جزء اصلی است:
1. **پکیج اصلی (Core package)**:
   - شامل کلاس‌ها و توابع مرتبط با منطق اصلی پروژه.
2. **پکیج سطح پایین (Utility/Tools package)**:
   - شامل ابزارها و توابع عمومی قابل استفاده مجدد، که هم در Core و هم در سایر بخش‌ها به کار می‌آیند.
3. **برنامه اصلی (Main Program / Application Layer)**:
   - بخشی که با استفاده از Core و Utility یک نسخه حداقلی و کاربردی از سیستم را اجرا می‌کند.
   - این بخش همان چیزی است که MVP را تبدیل به یک **برنامه واقعی و قابل اجرا** می‌کند.

🔑 بنابراین:
- **پکیج‌ها = زیرساخت و ستون فقرات MVP**
- **برنامه اصلی = MVP را به یک محصول کاربردی و عملیاتی تبدیل می‌کند**

## ساختار و عملکرد سیستم

این بخش رو کامل ننوشتم. قراره با هم کاملش کنیم.

### بخش‌ها
سیستم شامل **دو بخش اصلی** است:
- **دانشجو**
- **استاد** (هر استاد، هم استاد راهنما است و هم داور. بعدا توضیح خواهم داد)

کاربران (اساتید و دانشجویان) از قبل در سیستم تعریف شده‌اند (این بانک اطلاعاتی رو باید با هم بسازیم. اول یک سری کلاس تعریف می‌کنیم و بعد از اون کلاس‌ها استفاده می‌کنیم تا بانک اطلاعاتی‌مون رو دست‌نویس بسازیم. پس نیازی به قسمت گرفتن اطلاعات یا قسمت ثبت‌نام پیشرفته نیست و چنین بخشی در سامانه نخواهیم ساخت).

### 📌 بخش دانشجو
قابلیت‌ها:
1. **ورود به سیستم** با کد دانشجویی و رمز عبور  
   در ابتدای برنامه، تابع `Welcome_and_role_determination` اجرا خواهد شد. این تابع، بعد از خوشامدگویی، نقش کاربر رو خواهد پرسید: «دانشجو یا استاد؟». بر اساس اون صفحه بعدی رو باز خواهد کرد: یا `Welcome_Student` یا `Welcome_Professor`.  
   این توابع بعد از خوشامدگویی، باید دو گزینه `log_in` و `sign_up` رو در اختیار کاربر قرار بدن که در نسخه اولیه فقط `log_in` رو می‌سازیم و `sign_up` در حد نما باقی می‌گذاریم.  
   تابع `log_in` به‌طور جدا نوشته می‌شه (نه در درون `Welcome_Professor` یا `Welcome_Student`) و توسط این توابع (اگر input کاربر انتخابشون کنه)، صرفا صدا زده می‌شن. تابع `log_in`، کد دانشجویی یا استادی و رمز عبور رو می‌گیره و دانشجو یا استاد رو وارد حساب کاربریش می‌کنه (تابع دیگری رو صدا می‌زنه که این کار رو انجام بده). اینجا، در MVP، یک ساده‌سازی انجام می‌دیم و فعلا فقط یک استاد و دانشجو در نظر می‌گیریم که ساخت بخش‌هایی از تابع `log_in` رو بعد موکول کنیم. کد دانشجویی و رمز عبور دانشجو `0000` و کد استادی و رمز عبورش `1111` است. (چون در نسخه‌های بعد که چندین دانشجو و استاد در نظر بگیریم، بخش‌هایی برای مدیریت صفحات لازم می‌شه که فعلا می‌خوایم از زیر طراحی‌شون شونه خالی کنیم).  
   برای تابع `sign_in` یادآوری می‌کنم که **"مدیریت کاربران سامانه شامل ثبت یا ویرایش اطلاعات دانشجو و استاد نیست، بانک اطلاعاتی این کاربران را به‌صورت دستی در فایل مربوطه تکمیل خواهیم کرد. پس نیازی نیست که یک بخش برای پر کردن اطلاعات توسط کاربر بسازیم. پس تابع `sign_in` به کاربر پیام می‌ده که مهلت ثبت‌نام گذشته و تابع `log_in` رو صدا می‌زنه.**

2. **درخواست اخذ پایان‌نامه** از بین درس‌های دارای ظرفیت:
   - ثبت تاریخ درخواست به‌صورت سیستمی
   - ارسال برای استاد راهنما → استاد باید تأیید یا رد کند

3. **مشاهده وضعیت درخواست** ("در انتظار تأیید"، "تأیید شده"، "رد شده")

4. **ارسال مجدد درخواست** در صورت رد شدن

5. **ارسال درخواست دفاع** (بعد از ۳ ماه از تأیید) شامل:
   - فایل PDF پایان‌نامه
   - تصویر صفحه اول و آخر
   - چکیده و کلیدواژه‌ها
   - تیک آمادگی دفاع
   - ثبت تاریخ سیستم
   - نیازمند تأیید استاد راهنما و تعیین تاریخ دفاع و داوران

6. **جستجو در بانک پایان‌نامه‌ها** (دفاع‌شده) بر اساس:
   - عنوان، استاد، کلیدواژه‌ها، نویسنده، سال دفاع، داوران

اطلاعات خروجی جستجو:
- **عنوان**
- **چکیده**
- **کلیدواژه‌ها**
- **نویسنده**
- **استاد راهنما**
- **سال/نیمسال**
- **داوران**
- **لینک دانلود فایل**
- **نمره (الف/ب/ج/د)**

### 📌 بخش استاد

#### استاد راهنما
1. **ورود** با کد و رمز عبور
2. **مشاهده و بررسی درخواست‌های پایان‌نامه**:
   - امکان تأیید یا رد درخواست دانشجو
3. **مدیریت درخواست‌های دفاع**:
   - بررسی فایل و اطلاعات پایان‌نامه
   - تأیید یا رد آمادگی دفاع
   - انتخاب تاریخ دفاع
   - انتخاب داور داخلی و خارجی
   - پس از ثبت نمره، ظرفیت استاد آزاد می‌شود

#### داور (داخلی/خارجی)
- پس از برگزاری دفاع، نمره پایان‌نامه را ثبت می‌کند.

#### جستجو
- امکان جستجو در بانک پایان‌نامه‌ها مثل بخش دانشج


---
---

 
## ساختار برنامه (با جزئیات و مثال)

پرتابل بودن: پروژه بدون وابستگی به مسیرهای خاص یا داده‌های سخت‌کدشده اجرا می‌شود.
Single Source of Truth: داده‌ها در فایل‌های JSON ذخیره شده و از تکرار داده‌ها جلوگیری می‌شود.
مدیریت فایل‌ها: فایل‌های PDF و تصاویر در پوشه data/uploads ذخیره شده و مسیر آن‌ها در فایل‌های JSON ثبت می‌شود.
نام‌گذاری فایل‌ها: نام فایل‌ها باید شامل student_code و course_title باشد تا یکتا شوند.
سادگی و قابلیت توسعه: کد ساده اما قابل توسعه نوشته شده تا حتی با دانش محدود پایتون قابل فهم باشد.

زبان و ابزارها

زبان برنامه‌نویسی: Python
دیتابیس: فایل‌های JSON
رابط کاربری: Command Line Interface (CLI)
ذخیره‌سازی فایل‌ها: PDF و JPG در پوشه data/uploads با مسیرهای ثبت‌شده در JSON
تست: با استفاده از pytest برای تست‌های کوچک و جامع

ساختار پروژه

<img width="410" height="795" alt="Screenshot 1404-06-26 at 1 42 00 AM" src="https://github.com/user-attachments/assets/7e3adc71-5b35-4531-a25d-3ac8b72babab" />


├── data
│   ├── courses.json
│   ├── defended_thesis.json
│   ├── professors.json
│   ├── students.json
│   ├── thesis.json
│   └── uploads
│       └── test.pdf
├── history
│   └── changelog.txt
├── main_program.py
├── pytest.ini
├── README.md
├── src
│   ├── entities
│   │   ├── course.py
│   │   ├── defense.py
│   │   ├── professor.py
│   │   ├── student.py
│   │   ├── thesis.py
│   │   ├── user.py
│   │   └── README.md
│   ├── interfaces
│   │   ├── auth.py
│   │   ├── professor_menu.py
│   │   ├── student_menu.py
│   │   ├── welcome.py
│   │   └── README.md
│   ├── search
│   │   ├── search_engine.py
│   ├── storage
│   │   ├── file_manager.py
│   │   ├── json_storage.py
│   ├── utilities
│   │   ├── utils.py
│   ├── workflow
│   │   ├── thesis_workflow.py
└── tests
    ├── test_auth.py
    ├── test_comprehensive.py
    ├── test_entities.py
    ├── test_json_storage.py
    ├── test_main.py
    ├── test_menus.py
    ├── test_search.py
    ├── test_workflow.py

توضیحات ساختار

data/: شامل فایل‌های JSON برای ذخیره داده‌ها و پوشه uploads برای فایل‌های PDF و تصاویر.
history/: شامل فایل changelog.txt برای ثبت تغییرات نسخه‌ها.
main_program.py: نقطه ورود اصلی برنامه که از پکیج‌ها برای اجرای سیستم استفاده می‌کند.
src/: شامل پکیج‌های اصلی و سطح پایین پروژه:
entities/: کلاس‌های اصلی مانند User, Student, Professor, Course, Thesis, Defense.
interfaces/: رابط‌های کاربری CLI شامل خوشامدگویی، ورود، و منوهای دانشجو و استاد.
search/: موتور جست‌وجو برای پایان‌نامه‌های دفاع‌شده.
storage/: مدیریت ذخیره‌سازی داده‌ها (JSON و فایل‌ها).
utilities/: توابع عمومی و قابل استفاده مجدد.
workflow/: منطق فرآیندهای پایان‌نامه (مثل ثبت درخواست و دفاع).


tests/: شامل تست‌های کوچک و جامع برای اطمینان از عملکرد صحیح ماژول‌ها.

فایل‌های JSON
1. students.json
هدف: ذخیره اطلاعات دانشجویانفیلدها:

name: نام کامل دانشجو (str)
student_code: کد دانشجویی برای ورود (str)
password: رمز عبور (str)

مثال:
[
    {
        "name": "علی احمدی",
        "student_code": "0000",
        "password": "0000"
    }
]

2. professors.json
هدف: ذخیره اطلاعات اساتیدفیلدها:

name: نام استاد (str)
teacher_code: کد استادی برای ورود (str)
password: رمز عبور (str)
capacity_supervise: ظرفیت راهنمایی (int, اختیاری)
capacity_judge: ظرفیت داوری (int, اختیاری)

مثال:
[
    {
        "name": "دکتر محمدی",
        "teacher_code": "1111",
        "password": "1111",
        "capacity_supervise": 5,
        "capacity_judge": 10
    }
]

3. courses.json
هدف: ذخیره اطلاعات درس‌هافیلدها:

course_id: آیدی درس (str)
course_title: عنوان درس (str)
professor_code: کد استاد (str)
year: سال تحصیلی (int)
semester: نیمسال (str: "اول" یا "دوم")
capacity: ظرفیت (int)
resources: منابع درسی (list)
sessions: تعداد جلسات (int)
unit: تعداد واحد (int)

مثال:
[
    {
        "course_id": "C001",
        "course_title": "هوش مصنوعی پیشرفته",
        "professor_code": "1111",
        "year": 2025,
        "semester": "اول",
        "capacity": 10,
        "resources": ["کتاب"],
        "sessions": 10,
        "unit": 3
    },
    {
        "course_id": "C002",
        "course_title": "یادگیری ماشین پیشرفته",
        "professor_code": "1111",
        "year": 2025,
        "semester": "اول",
        "capacity": 10,
        "resources": ["کتاب"],
        "sessions": 10,
        "unit": 3
    }
]

4. thesis.json
هدف: ذخیره درخواست‌های اخذ پایان‌نامهفیلدها:

student_code: کد دانشجو (str)
course_id: آیدی درس (str)
request_date: تاریخ ثبت درخواست (str, فرمت YYYY-MM-DD)
approval_date: تاریخ تأیید (str, فرمت YYYY-MM-DD)
status: وضعیت درخواست (str: "pending", "approved", "rejected", "defending")
defense_date: تاریخ دفاع (str, اختیاری)
files: مسیر فایل‌های PDF/تصاویر (list)
score: نمره (float, اختیاری)
judges: لیست داوران (list)

شناسه یکتا: ترکیب student_code + course_idمثال:
[
    {
        "student_code": "0000",
        "course_id": "C001",
        "request_date": "2025-09-16",
        "approval_date": "2025-09-16",
        "status": "approved",
        "defense_date": null,
        "files": [],
        "score": null,
        "judges": []
    }
]

5. defended_thesis.json
هدف: آرشیو پایان‌نامه‌های دفاع‌شدهفیلدها:

student_code: کد دانشجو (str)
course_id: آیدی درس (str)
title: عنوان پایان‌نامه (str)
year: سال دفاع (int)
semester: نیمسال دفاع (str)
supervisor: کد استاد راهنما (str)
judges: لیست داوران (list)
score: نمره نهایی (float)
files: مسیر فایل‌های PDF/تصاویر (list)
keywords: کلمات کلیدی (list)

مثال:
[
    {
        "student_code": "0000",
        "course_id": "C002",
        "title": "کاربرد هوش مصنوعی در آموزش",
        "year": 2025,
        "semester": "اول",
        "supervisor": "1111",
        "judges": [],
        "score": null,
        "files": ["data/uploads/0000_یادگیری_ماشین_پیشرفته_test.pdf"],
        "keywords": ["هوش مصنوعی", "آموزش"]
    }
]

کار با فایل‌های JSON در Python
JSON (JavaScript Object Notation) یک فرمت سبک برای ذخیره و انتقال داده‌هاست که در این پروژه برای ذخیره اطلاعات کاربران، درس‌ها، و پایان‌نامه‌ها استفاده می‌شه. در پایتون، ماژول json برای کار با فایل‌های JSON استفاده می‌شه. در ادامه، یه آموزش ساده و گام‌به‌گام برای کار با JSON ارائه می‌شه:
1. خواندن از فایل JSON
برای خواندن داده‌ها از یه فایل JSON (مثل students.json):
import json

with open("data/students.json", "r", encoding="utf-8") as file:
    data = json.load(file)  # داده‌ها به‌صورت لیست یا دیکشنری لود می‌شن
print(data)  # مثال: [{'name': 'علی احمدی', 'student_code': '0000', 'password': '0000'}]


نکته: همیشه از encoding="utf-8" استفاده کن تا متن‌های فارسی درست خونده بشن.
خطاها: اگه فایل وجود نداشته باشه، FileNotFoundError رخ می‌ده. می‌تونی با try-except مدیریتش کنی.

2. نوشتن در فایل JSON
برای اضافه کردن داده جدید به فایل JSON:
import json

داده جدید
new_student = {"name": "رضا محمدی", "student_code": "0001", "password": "0001"}
data = []

خواندن داده‌های قبلی
try:
    with open("data/students.json", "r", encoding="utf-8") as file:
        data = json.load(file)
except FileNotFoundError:
    data = []

اضافه کردن داده جدید
data.append(new_student)

ذخیره در فایل
with open("data/students.json", "w", encoding="utf-8") as file:
    json.dump(data, file, ensure_ascii=False, indent=4)


ensure_ascii=False: باعث می‌شه متن‌های فارسی درست ذخیره بشن.
indent=4: فایل JSON رو خوانا و با فرمت مرتب ذخیره می‌کنه.

3. ویرایش فایل JSON
برای ویرایش یه رکورد خاص:
import json

خواندن داده‌ها
with open("data/students.json", "r", encoding="utf-8") as file:
    data = json.load(file)

ویرایش (مثلاً تغییر رمز عبور دانشجو با کد 0000)
for student in data:
    if student["student_code"] == "0000":
        student["password"] = "new_password"
ذخیره تغییرات
with open("data/students.json", "w", encoding="utf-8") as file:
    json.dump(data, file, ensure_ascii=False, indent=4)

نکات مهم

پرتابل بودن: همیشه از مسیرهای نسبی (مثل data/students.json) به جای مسیرهای مطلق (مثل /Users/amirmahdi/...) استفاده کن.
مدیریت خطا: همیشه خطاهای احتمالی (مثل نبود فایل) رو با try-except مدیریت کن.
ساختار JSON: داده‌ها معمولاً به‌صورت لیست دیکشنری‌ها ذخیره می‌شن ([{...}, {...}]).

قابلیت‌های MVP
بخش دانشجو

ورود: با کد دانشجویی (0000) و رمز عبور (0000) از طریق auth.py و welcome.py.
مشاهده درس‌ها: نمایش درس‌های دارای ظرفیت از courses.json.
درخواست پایان‌نامه: ثبت درخواست برای درس با course_id مشخص (در MVP خودکار تأیید می‌شه).
درخواست دفاع: ثبت عنوان، کلمات کلیدی، و فایل PDF برای درس تأییدشده.
جستجو: جستجو در defended_thesis.json بر اساس عنوان، نویسنده، یا کلمات کلیدی.

بخش استاد

ورود: با کد استادی (1111) و رمز عبور (1111).
مشاهده درخواست‌ها: نمایش درخواست‌های پایان‌نامه از thesis.json.
مدیریت دفاع: تأیید/رد درخواست دفاع، انتخاب تاریخ و داوران.
ثبت نمره: ثبت نمره توسط داور (در MVP بدون محدودیت زمانی).
جستجو: مشابه بخش دانشجو.

بخش‌های موکول‌شده به نسخه‌های بعدی

مشاهده وضعیت درخواست: در MVP فقط نمایشی است (همه درخواست‌ها خودکار تأیید می‌شن).
ارسال مجدد درخواست: در MVP فقط نمایشی است.
محدودیت ظرفیت استاد: در MVP محدودیتی برای راهنمایی/داوری وجود نداره.
محدودیت زمانی دفاع: در MVP نیازی به انتظار ۳ ماه نیست.
چکیده و تصاویر: در MVP فقط فایل PDF ذخیره می‌شه.

نحوه اجرا

نصب وابستگی‌ها:pip install pytest


اجرای برنامه:python main_program.py


نقش (دانشجو: 1، استاد: 2) را انتخاب کنید.
کد و رمز عبور وارد کنید (دانشجو: 0000/0000، استاد: 1111/1111).
از منوها برای انجام عملیات استفاده کنید.


اجرای تست‌ها:pytest tests/test_comprehensive.py -s



نکات توسعه

تست‌ها: تست‌های کوچک در فایل‌های test_*.py برای هر ماژول نوشته شده‌اند. تست جامع در test_comprehensive.py عملکرد کلی سیستم رو بررسی می‌کنه.
شبه‌کد: قبل از توسعه هر ماژول، شبه‌کد ماژولار نوشته شده و در پوشه history داکیومنت می‌شه.
گام‌های بعدی:
بهبود اعتبارسنجی ورودی‌ها (مثل فرمت تاریخ).
تکمیل بخش‌های نمایشی (وضعیت درخواست، ارسال مجدد).
اضافه کردن محدودیت‌های ظرفیت و زمان‌بندی.



  ادامه توسعه و نکات مربوط به فایل های JSON (ادامه)
برای توسعه‌دهندگان جدید:

همیشه از مسیرهای نسبی استفاده کنید (مثل data/thesis.json).
قبل از نوشتن/خواندن، وجود فایل رو با try-except چک کنید.
برای مدیریت فایل‌های PDF، مسیر رو در JSON ذخیره کنید و از نام‌گذاری یکتا (مثل student_code_course_title.pdf) استفاده کنید.


این پروژه با تأکید بر سادگی، ماژولاریتی، و قابلیت توسعه طراحی شده و آماده گسترش در نسخه‌های بعدی است. برای جزئیات بیشتر، به فایل‌های شبه‌کد در history و تست‌ها در tests مراجعه کنید.

