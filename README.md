امیرمهدی رضائی / کد دانشجویی ۴۰۳۱۰۳۱۱۰ / کد ملی ۰۳۷۳۰۱۱۲۳۷

https://github.com/AmirMahdiRezaeiEECS/thesis-project-introduction-to-Multi-Agent-AI-medels-

سیستم مدیریت پایان‌نامه‌ها
این پروژه یک سیستم مدیریت پایان‌نامه‌ها است که برای مدیریت فرآیند پایان‌نامه‌ها از مرحله اخذ درس تا ارزیابی نهایی طراحی شده است. هدف اصلی، ایجاد یک نسخه حداقلی (MVP) کامل، کاربردی و قابل توسعه است که با استفاده از برنامه‌نویسی شیءگرا (OOP) و طراحی ماژولار پیاده‌سازی شده است.
هدف MVP: ارائه یک سیستم قابل اجرا با امکانات پایه که ساختار قوی و آینده‌نگرانه‌ای برای توسعه نسخه‌های بعدی داشته باشد. بخش‌های کم‌اهمیت به نسخه‌های بعدی موکول شده‌اند، اما ساختار و عملکرد کلی حتی در نسخه اول کامل است.
اصول و الزامات کلیدی

ماژولاریتی و شیءگرایی: کد به‌صورت ماژولار و با استفاده از اصول OOP نوشته شده تا خوانا، قابل نگهداری و قابل توسعه باشد.
پرتابل بودن: پروژه بدون وابستگی به مسیرهای خاص یا داده‌های سخت‌کدشده اجرا می‌شود.
Single Source of Truth: داده‌ها در فایل‌های JSON ذخیره شده و از تکرار داده‌ها جلوگیری می‌شود.
مدیریت فایل‌ها: فایل‌های PDF و تصاویر در پوشه data/uploads ذخیره شده و مسیر آن‌ها در فایل‌های JSON ثبت می‌شود.
نام‌گذاری فایل‌ها: نام فایل‌ها باید شامل student_code و course_title باشد تا یکتا شوند.
سادگی و قابلیت توسعه: کد ساده اما قابل توسعه نوشته شده تا حتی با دانش محدود پایتون قابل فهم باشد.

زبان و ابزارها

زبان برنامه‌نویسی: Python
دیتابیس: فایل‌های JSON
رابط کاربری: Command Line Interface (CLI)
ذخیره‌سازی فایل‌ها: PDF و JPG در پوشه data/uploads با مسیرهای ثبت‌شده در JSON
تست: با استفاده از pytest برای تست‌های کوچک و جامع

ساختار پروژه
├── data
│   ├── courses.json
│   ├── defended_thesis.json
│   ├── professors.json
│   ├── students.json
│   ├── thesis.json
│   └── uploads
│       └── test.pdf
├── history
│   └── changelog.txt
├── main_program.py
├── pytest.ini
├── README.md
├── src
│   ├── entities
│   │   ├── course.py
│   │   ├── defense.py
│   │   ├── professor.py
│   │   ├── student.py
│   │   ├── thesis.py
│   │   ├── user.py
│   │   └── README.md
│   ├── interfaces
│   │   ├── auth.py
│   │   ├── professor_menu.py
│   │   ├── student_menu.py
│   │   ├── welcome.py
│   │   └── README.md
│   ├── search
│   │   ├── search_engine.py
│   ├── storage
│   │   ├── file_manager.py
│   │   ├── json_storage.py
│   ├── utilities
│   │   ├── utils.py
│   ├── workflow
│   │   ├── thesis_workflow.py
└── tests
    ├── test_auth.py
    ├── test_comprehensive.py
    ├── test_entities.py
    ├── test_json_storage.py
    ├── test_main.py
    ├── test_menus.py
    ├── test_search.py
    ├── test_workflow.py

توضیحات ساختار

data/: شامل فایل‌های JSON برای ذخیره داده‌ها و پوشه uploads برای فایل‌های PDF و تصاویر.
history/: شامل فایل changelog.txt برای ثبت تغییرات نسخه‌ها.
main_program.py: نقطه ورود اصلی برنامه که از پکیج‌ها برای اجرای سیستم استفاده می‌کند.
src/: شامل پکیج‌های اصلی و سطح پایین پروژه:
entities/: کلاس‌های اصلی مانند User, Student, Professor, Course, Thesis, Defense.
interfaces/: رابط‌های کاربری CLI شامل خوشامدگویی، ورود، و منوهای دانشجو و استاد.
search/: موتور جست‌وجو برای پایان‌نامه‌های دفاع‌شده.
storage/: مدیریت ذخیره‌سازی داده‌ها (JSON و فایل‌ها).
utilities/: توابع عمومی و قابل استفاده مجدد.
workflow/: منطق فرآیندهای پایان‌نامه (مثل ثبت درخواست و دفاع).


tests/: شامل تست‌های کوچک و جامع برای اطمینان از عملکرد صحیح ماژول‌ها.

فایل‌های JSON
1. students.json
هدف: ذخیره اطلاعات دانشجویانفیلدها:

name: نام کامل دانشجو (str)
student_code: کد دانشجویی برای ورود (str)
password: رمز عبور (str)

مثال:
[
    {
        "name": "علی احمدی",
        "student_code": "0000",
        "password": "0000"
    }
]

2. professors.json
هدف: ذخیره اطلاعات اساتیدفیلدها:

name: نام استاد (str)
teacher_code: کد استادی برای ورود (str)
password: رمز عبور (str)
capacity_supervise: ظرفیت راهنمایی (int, اختیاری)
capacity_judge: ظرفیت داوری (int, اختیاری)

مثال:
[
    {
        "name": "دکتر محمدی",
        "teacher_code": "1111",
        "password": "1111",
        "capacity_supervise": 5,
        "capacity_judge": 10
    }
]

3. courses.json
هدف: ذخیره اطلاعات درس‌هافیلدها:

course_id: آیدی درس (str)
course_title: عنوان درس (str)
professor_code: کد استاد (str)
year: سال تحصیلی (int)
semester: نیمسال (str: "اول" یا "دوم")
capacity: ظرفیت (int)
resources: منابع درسی (list)
sessions: تعداد جلسات (int)
unit: تعداد واحد (int)

مثال:
[
    {
        "course_id": "C001",
        "course_title": "هوش مصنوعی پیشرفته",
        "professor_code": "1111",
        "year": 2025,
        "semester": "اول",
        "capacity": 10,
        "resources": ["کتاب"],
        "sessions": 10,
        "unit": 3
    },
    {
        "course_id": "C002",
        "course_title": "یادگیری ماشین پیشرفته",
        "professor_code": "1111",
        "year": 2025,
        "semester": "اول",
        "capacity": 10,
        "resources": ["کتاب"],
        "sessions": 10,
        "unit": 3
    }
]

4. thesis.json
هدف: ذخیره درخواست‌های اخذ پایان‌نامهفیلدها:

student_code: کد دانشجو (str)
course_id: آیدی درس (str)
request_date: تاریخ ثبت درخواست (str, فرمت YYYY-MM-DD)
approval_date: تاریخ تأیید (str, فرمت YYYY-MM-DD)
status: وضعیت درخواست (str: "pending", "approved", "rejected", "defending")
defense_date: تاریخ دفاع (str, اختیاری)
files: مسیر فایل‌های PDF/تصاویر (list)
score: نمره (float, اختیاری)
judges: لیست داوران (list)

شناسه یکتا: ترکیب student_code + course_idمثال:
[
    {
        "student_code": "0000",
        "course_id": "C001",
        "request_date": "2025-09-16",
        "approval_date": "2025-09-16",
        "status": "approved",
        "defense_date": null,
        "files": [],
        "score": null,
        "judges": []
    }
]

5. defended_thesis.json
هدف: آرشیو پایان‌نامه‌های دفاع‌شدهفیلدها:

student_code: کد دانشجو (str)
course_id: آیدی درس (str)
title: عنوان پایان‌نامه (str)
year: سال دفاع (int)
semester: نیمسال دفاع (str)
supervisor: کد استاد راهنما (str)
judges: لیست داوران (list)
score: نمره نهایی (float)
files: مسیر فایل‌های PDF/تصاویر (list)
keywords: کلمات کلیدی (list)

مثال:
[
    {
        "student_code": "0000",
        "course_id": "C002",
        "title": "کاربرد هوش مصنوعی در آموزش",
        "year": 2025,
        "semester": "اول",
        "supervisor": "1111",
        "judges": [],
        "score": null,
        "files": ["data/uploads/0000_یادگیری_ماشین_پیشرفته_test.pdf"],
        "keywords": ["هوش مصنوعی", "آموزش"]
    }
]

آموزش کار با فایل‌های JSON در Python
JSON (JavaScript Object Notation) یک فرمت سبک برای ذخیره و انتقال داده‌هاست که در این پروژه برای ذخیره اطلاعات کاربران، درس‌ها، و پایان‌نامه‌ها استفاده می‌شه. در پایتون، ماژول json برای کار با فایل‌های JSON استفاده می‌شه. در ادامه، یه آموزش ساده و گام‌به‌گام برای کار با JSON ارائه می‌شه:
1. خواندن از فایل JSON
برای خواندن داده‌ها از یه فایل JSON (مثل students.json):
import json

with open("data/students.json", "r", encoding="utf-8") as file:
    data = json.load(file)  # داده‌ها به‌صورت لیست یا دیکشنری لود می‌شن
print(data)  # مثال: [{'name': 'علی احمدی', 'student_code': '0000', 'password': '0000'}]


نکته: همیشه از encoding="utf-8" استفاده کن تا متن‌های فارسی درست خونده بشن.
خطاها: اگه فایل وجود نداشته باشه، FileNotFoundError رخ می‌ده. می‌تونی با try-except مدیریتش کنی.

2. نوشتن در فایل JSON
برای اضافه کردن داده جدید به فایل JSON:
import json

# داده جدید
new_student = {"name": "رضا محمدی", "student_code": "0001", "password": "0001"}
data = []

# خواندن داده‌های قبلی
try:
    with open("data/students.json", "r", encoding="utf-8") as file:
        data = json.load(file)
except FileNotFoundError:
    data = []

# اضافه کردن داده جدید
data.append(new_student)

# ذخیره در فایل
with open("data/students.json", "w", encoding="utf-8") as file:
    json.dump(data, file, ensure_ascii=False, indent=4)


ensure_ascii=False: باعث می‌شه متن‌های فارسی درست ذخیره بشن.
indent=4: فایل JSON رو خوانا و با فرمت مرتب ذخیره می‌کنه.

3. ویرایش فایل JSON
برای ویرایش یه رکورد خاص:
import json

# خواندن داده‌ها
with open("data/students.json", "r", encoding="utf-8") as file:
    data = json.load(file)

# ویرایش (مثلاً تغییر رمز عبور دانشجو با کد 0000)
for student in data:
    if student["student_code"] == "0000":
        student["password"] = "new_password"

# ذخیره تغییرات
with open("data/students.json", "w", encoding="utf-8") as file:
    json.dump(data, file, ensure_ascii=False, indent=4)

نکات مهم

پرتابل بودن: همیشه از مسیرهای نسبی (مثل data/students.json) به جای مسیرهای مطلق (مثل /Users/amirmahdi/...) استفاده کن.
مدیریت خطا: همیشه خطاهای احتمالی (مثل نبود فایل) رو با try-except مدیریت کن.
ساختار JSON: داده‌ها معمولاً به‌صورت لیست دیکشنری‌ها ذخیره می‌شن ([{...}, {...}]).

قابلیت‌های MVP
بخش دانشجو

ورود: با کد دانشجویی (0000) و رمز عبور (0000) از طریق auth.py و welcome.py.
مشاهده درس‌ها: نمایش درس‌های دارای ظرفیت از courses.json.
درخواست پایان‌نامه: ثبت درخواست برای درس با course_id مشخص (در MVP خودکار تأیید می‌شه).
درخواست دفاع: ثبت عنوان، کلمات کلیدی، و فایل PDF برای درس تأییدشده.
جستجو: جستجو در defended_thesis.json بر اساس عنوان، نویسنده، یا کلمات کلیدی.

بخش استاد

ورود: با کد استادی (1111) و رمز عبور (1111).
مشاهده درخواست‌ها: نمایش درخواست‌های پایان‌نامه از thesis.json.
مدیریت دفاع: تأیید/رد درخواست دفاع، انتخاب تاریخ و داوران.
ثبت نمره: ثبت نمره توسط داور (در MVP بدون محدودیت زمانی).
جستجو: مشابه بخش دانشجو.

بخش‌های موکول‌شده به نسخه‌های بعدی

مشاهده وضعیت درخواست: در MVP فقط نمایشی است (همه درخواست‌ها خودکار تأیید می‌شن).
ارسال مجدد درخواست: در MVP فقط نمایشی است.
محدودیت ظرفیت استاد: در MVP محدودیتی برای راهنمایی/داوری وجود نداره.
محدودیت زمانی دفاع: در MVP نیازی به انتظار ۳ ماه نیست.
چکیده و تصاویر: در MVP فقط فایل PDF ذخیره می‌شه.

نحوه اجرا

نصب وابستگی‌ها:pip install pytest


اجرای برنامه:python main_program.py


نقش (دانشجو: 1، استاد: 2) را انتخاب کنید.
کد و رمز عبور وارد کنید (دانشجو: 0000/0000، استاد: 1111/1111).
از منوها برای انجام عملیات استفاده کنید.


اجرای تست‌ها:pytest tests/test_comprehensive.py -s



نکات توسعه

تست‌ها: تست‌های کوچک در فایل‌های test_*.py برای هر ماژول نوشته شده‌اند. تست جامع در test_comprehensive.py عملکرد کلی سیستم رو بررسی می‌کنه.
شبه‌کد: قبل از توسعه هر ماژول، شبه‌کد ماژولار نوشته شده و در پوشه history داکیومنت می‌شه.
گام‌های بعدی:
بهبود اعتبارسنجی ورودی‌ها (مثل فرمت تاریخ).
تکمیل بخش‌های نمایشی (وضعیت درخواست، ارسال مجدد).
اضافه کردن محدودیت‌های ظرفیت و زمان‌بندی.



آموزش JSON (ادامه)
برای توسعه‌دهندگان جدید:

همیشه از مسیرهای نسبی استفاده کنید (مثل data/thesis.json).
قبل از نوشتن/خواندن، وجود فایل رو با try-except چک کنید.
برای مدیریت فایل‌های PDF، مسیر رو در JSON ذخیره کنید و از نام‌گذاری یکتا (مثل student_code_course_title.pdf) استفاده کنید.


این پروژه با تأکید بر سادگی، ماژولاریتی، و قابلیت توسعه طراحی شده و آماده گسترش در نسخه‌های بعدی است. برای جزئیات بیشتر، به فایل‌های شبه‌کد در history و تست‌ها در tests مراجعه کنید.


پرامپت مورد استفاده برای همکاری با مدل های زبانی : 



## شرح پروژه پایتون :‌ "سيستم مديريت پايان نامه ها"


پروثه ما "طراحى و يياده سازى يك سامانه براى مديريت فرآيند پايان نامهها" است. هدف از اين پروزه، ايجاد يك سيستم جامع وكاربردى است كه تمام مراحل يك پايان نامه، از اغاز روند اخذ درس يايان نامه تا ارزيابى نهايى را مديريت كند. 

**فعلا  برای ساخت نسخه اول ، فقط یک نسخه حداقلی (Minimum Viable Product) که کامل باشه و کار کنه خواهیم ساخت و بخش های کم اهمیت که به کارکرد کلی برنامه آسیبی نمی زنن ، به نسخه دوم واگذار خواهند شد .**


### **📌 نکات و الزامات**

- **مديريت كاربران سامانه شامل ثبت يا ويرايش اطلاعات دانشجو و استاد نيست، بانك اطلاعاتي اين كاربران رابه صورت دستى در فايل مربوطه تكميل خواهیم کرد .** 
    
- **براى ذخيره داده بايد از فرمت داده json استفاده كردد، كليه فايل های دیگر نیز ( pdf، تصاوير و ...)بايد در فولدر مربوطه ذخيره شود و مسيرآن ها در صورت نياز در فايل هاى json جایگذاری شوند.**
    
- **اصل ماژولار بودن و شیءگرایی رعایت شود.**


## **زبان و ابزارها**

- زبان برنامه‌نویسی: Python
    
- دیتابیس: فایل‌های JSON
    
- محیط کاربری: Command Line Interface (CLI)
    
- ذخیره‌ی فایل‌ها: pdf, jpg در پوشه‌های مربوطه، مسیرشان در JSON نگهداری می‌شود



### تعريف عملكردها و بخش هاى اصلى سيستم

#### سامانه بايد از دو بخش اصلى تشكيل شود: بخش دانشجو و بخش استاد.

* دانشجويان و اساتيد از قبل در سيستم ذخيره شده اند.
* براى هر استاد دروس آن تعريف شده است

بايان نامه در قالب يك درس توسط دانشجو اخذ میگردد و يايان نامه با اساتيد مختلف ارائه ميشود. اطلاعات درس ها در سامانه به صورت زير ميبايست مديريت شود:

• آيدى (يونيك)
• عنوان
• استاد
• سال 
• نيمسال (نيمسال اول/دوم)
• ظرفيت
• منابع درسى
• تعداد جلسات
• واحد

#### ١. بخش دانشجو :

اين بخش براى مديريت فعاليت هاى دانشجو در فرايند پايان نامه است و شامل قابليت هاى زير است:

##### ا. ورود

دانشجو بايد بتواند باكد دانشجويى ورمز عبور وارد سيستم شود.

##### ٢. درخواست اخذ درس پايان نامه

دانشجو ميبايست بتواند درخواست اخذ پايان نامه را از بين درسهاى داراى ظرفيت ثبت نمايد.

##### ۳. مشاهده وضعيت درس پايان نامه 

دانشجو بايد بتواند وضعيت درخواست اخذ خود را مشاهده كند ("در انتظار تأييد استاد"، "تأييد شده"، "رد شده").در نسخه اولیه برنامه ، این صرفا نمای این بخش را می سازیم . یعنی در نسخه اولیه برنامه ما ، درخواست ها همه تایید شده اند و نیاز به درخواست از استاد و گرفتن تائید ندارند. اما در نسخه های بعد این بخش از حالت نمایشی به حالت واقعی تغییر خواهد کرد . یعنی واقعا باید درخواست ثبت شود و منتظر تائيد استاد بمانیم . 

##### ۴.ارسال مجدد درخواست اخذ درس يايان نامه

در صورت رد شدن درخواست توسط استاد؛ دانشجو بايد امكان درخواست مجدد براى اخذ درس پايان نامه را داشته باشد. (این بخش هم در نسخه اول فقط نما است و در نسخه های بعد تکمیل می شود . پس برای نسخه اول ، فقط نمایی از این بخش را خواهیم ساخت و عملکرد اش را به نسخه های بعد موکول خواهیم کرد )

##### ۵. ارسال درخواست دفاع

در صورت تاييد شدن درخواست اخذ پايان نامه، دانشجو ميبايست بتواند درخواست دفاع دهد. ثبت درخواست دفاع شامل ثبت فايل هاى نهايى می باشد. (در نسخه اول برنامه ، نیازی به تائید استاد نیست اما در نسخه دوم ، درخواست دفاع نيز جهت نهايى شدن نيازمند تاييد استاد راهنما ، انتخاب تاريخ دفاع و داوران توسط استاد است ، پس دانشجو ميبابست بتواند وضعيت درخواست خود را ببيند و استاد نيز بايد بتواند درخواستهاى دفاع ارسالى براى خود را مديريت نمايد.)

مواردى كه درج ان براى پايان نامه ضرورى است:

**• عنوان**
**• نويسنده**
• سال/ نيمسال
• داوران
• استاد راهنما
• **فايل pdf شامل متن يايان نامه**
**• نتيجه ى دفاع : دفاع/دفاع مجدد**
**• کلمات کلیدی (برای اینکه بعدا موتور جست و جوی برنامه بتونه سرچ کنه )**

##### ۶. جستجوى در بانك پایان نامه ها

كليه كاربران اعم از دانشجويان يا اساتيد بايد بتوانند در آرشيو پايان نامه هاى قبلى ( پايان نامه هاى دفاع شده و مختومه) جستجو كند . 

#### ٢. بخش استاد 

اين بخش براى مديريت فرايندهاى مربوط به پايان نامه هاى دانشجويان توسط استاد است و شامل قابليت هاى زير مى شود

##### ۱. ورود

استاد بايد بتواند باكد استادى و رمز عبور خود وارد شود.

##### ۲. بخش استاد راهنما

###### مشاهده بررسى وتأييد ليست درخواست هاى اخذ يايان نامه:
استاد بايد بتواند ليست درخواست هاى دانشجويان براى انتخاب يايان نامه با خود را ببيند همجنين بايد بتواند درخواست هاى دانشجويان را بررسى كرده وآنهارا "تأييد" يا"رد"كند.

نكته: در نسخه های بعدی ، هر استاد ۵ ظرفيت براى استاد راهنمايى و ١٠ ظرفيت براى داورى دارد. اما در نسخه اولیه محدودیتی وجود ندارد . 

###### مشاهده فایل و اطلاعات پایان نامه 

استاد بايد بتواند فايل و اطلاعات پايان نامه دانشجو را بررسى كند. 

###### تاييد و مديريت درخواست هاى دفاع ارسالى

در نسخه های بعدی برنامه ، تاريخ دفاع و داورها (يك داور داخلى و يك داور خارجى) توسط استاد راهنما انتخاب می شود .(اين موارد به معنى تاييد آغاز فرآيند دفاع است در غير اين صورت راهنما بايد بتواند درخواست دفاع را رد كند). این بخش باید در نسخه اولیه برنامه نیز ساخته شود . 

(در نسخه های بعدی برنامه ،  پس از گذشت سه ماه از تائيد اخذ پایان نامه ، اجازه اعلام آمادگی دانشجو برای جلسه دفاع صادر می شود . اما در نسخه اولیه ،‌ چنین محدودیتی وجود ندارد و دانشجو هر زمان بعد از تائيد اخذ پایان نامه ، می تواند برای جلسه دفاع درخواست دهد . نكته: پس ازثبت نمره توسط داوران عملا فرآيند دفاع به اتمام رسده و ظرفيت استاد براى استاد راهنما يا داورى ( بسته به موقعيت آن ) ميبايست بازشود.)

###### بخش داور

اساتید می توانند داوری پایان نامه ها را نیز بر عهده بگیرند .

دراين بخش در نظر بگیرید که استاد راهنما خارج از سامانه مراتب هماهنگی با داوران را انجام ميدهد (نیازی به ساخت بخش های هماهنگی بین داوران و اساتید و ... نیست) و با انتخاب داور ديكَر نيازى به تاييد داور نيست و داور صرفا پس از برگذاری جلسه دفاع ( پس از تاريخ دفاع ثبت شده) ، بايد بتوانند نمره پايان نامه را ثبت نمايند . 

###### جست و جو در بانک پایان نامه ها 

كليه كاربران اعم از دانشجويان يا اساتيد بايد بتوانند در آرشيو پايان نامه هاى قبلى ( پايان نامه هاى دفاع شده و مختومه) جستجو كند . 


#### ۳. موتور جست و جو 

همانطور که پیشتر گفته شد ، موتور جست و جوی مورد استفاده اساتید و دانشجویان یکسان است و نتيجه جستجو ميبايست در قالب اطلاعات زير نمايش يابد : 

• عنوان
• نويسنده
• سال/ نيمسال
• داوران
• استاد راهنما
• لينك دانلود فايل



---
---


## روش برنامه نویسی ما

من دانش و تجربه زیادی در پایتون ندارم . کمی پایتون بلدم و کمی OOP بلدم اما در عین حال ،‌ پروژه سختی در پیش دارم . پس باید از اصول زیر پیروی کنیم : 

### سادگی + قابلیت نگهداری و توسعه بالا

با توجه به اینکه من برنامه نویس حرفه ای نیستم ، باید از کد های ساده استفاده کنیم اما کد هارو به شکلی قابل نگهداری و توسعه بنویسیم که قابلیت نگهداری و توسعه داشته باشند . 

### شی گرایی و ماژولاریتی 

**مهم ترین مسئله در روش برنامه نویسی ما ،‌ شی گرایی و ماژولاریتی برنامه است . این برای من خیلی خیلی مهمه . باید یک کتاب خانه یا پکیج بنویسیم که کلاس ها ، توابع و .... که قراره در کد اصلی مون استفاده کنیم رو اونجا بسازیم . چون میخواهم کد اصلی خیلی تمیز و مختصر باشه و پیچیدگی های کد در یک جا متمرکز نشه  ؛ پس باید هر بخش رو ساده طراحی کنیم و از کنار هم قرار دادن بخش های ساده (با استفاده از ماژول هایی که نوشتیم)،‌بخش های پیچیده تر رو بسازیم .** 

### نسخه اولیه حداقلی قابل نگهداری و توسعه 

**نسخه های اولیه برنامه باید ساده و حداقلی باشد . بخش هایی از برنامه که به عملکرد کلی برنامه صدمه وارد نمی کنند ناقض باقی بمانند اما به شکلی ماژولار و قابل توسعه نوشته شوند که در نسخه های بعدی قابلیت کامل کردن داشته باشند . در عین حال ، بخش های اصلی برنامه باید کامل باشند عملکرد کلی برنامه باید حتی در اولین نسخه ، تضمین شود . یعنی اگر چه برخی بخش ها ناقص هستند اما برنامه باید به طور کامل اجرا شود .** 

بعد از ساخت نسخه اولیه ، نسخه به نسخه ،‌بخش های ناقصِ اسکلت اولیه را کامل خواهیم کرد . 


#### هشدار : ساختار کلی و  عملکرد نسخه های حداقلی نیز باید کامل باشد 

**حداقلی بودن کد و ناقص گذاشتن برخی بخش ها ،‌ به معنای ناقص بودن ساختار نیست . حتی اگر پوشه بعضی قسمت های ساختار الان خالی بمونن ،‌باید ساختار کلی برنامه رو اصولی جلو ببریم که بعدا در نسخه های بعد قابلیت کامل شدن و گسترش داشته باشه .**
**علاوه بر کامل بودن ساختار ، عملکرد کلی برنامه نیز باید کامل باشه .** 

### نوشتن شبه کد (Pseudocode) قبل از نوشتن کد اصلی و در طول توسعه

برای تمام بخش های برنامه از جمله ماژول ها ،‌ قبل از کد نویسی ،‌ گام به گام و با مشورت هم ،‌شبه کد برنامه رو بنویسیم ،‌ بعد از توافق روی اجزا برنامه ،‌شروع به کد نویسی خواهیم کرد . 

**نوشتن شبه کد به ما کمک میکنه که بدون درگیری با syntax ، روی جزئیات برنامه مون کار کنیم و بخش های مبهم رو شفاف کنیم و تصمیمات لازم رو قبل از درگیری با syntax بگیریم.** 

شبه کد ها ،‌بخش مهمی از برنامه اند . پس اونهارو هم مثل کد اصلی ،‌در قالب داکیومت ،‌نگهداری می کنیم و توسعه می دیم .

**ساختار شبه کد ها هم باید مطابق ساختار کد ،‌ماژولار و بر اساس شی گرایی باشه و حتی نگهداری شبه کد ها هم در ساختاری منظم انجام بشه . انگار که واقعا داریم برنامه رو مینویسیم .**

### توسعه گام به گام 

**باید گام به گام و با گام هایی کوچک جلو بریم . گام هایی کوچک و حداقلی که همگی باید با مشورت من انجام شوند.** 

### تست های گام به گام 

**بعد از هر گام ،‌ باید عملکرد بخش نوشته شده را تست کنیم** . من تست های کوچک را به تست های جامع ترجیح می دهم . در نهایت بعد از اینکه تست های کوچک انجام شد و گام به گام جلو رفتیم ، تست های جامع تر نیز انجام خواهیم داد . 

### توسعه نسخه به نسخه محافظه کارانه

در حین ساخت نسخه حداقلی اول ، انتقادات ،‌ پیشنهادات و برنامه مون برای ساخت نخسه های آینده رو داکیومنت خواهیم کرد . 

بعد از پایان توسعه ورژن حداقلی (اما با عملکرد صحیح) و انجام تست های لازم و راضی بودن از نتیجه ؛ نوبت به توسعه بیشتر سیستم خواهد رسید . در این مرحله هم محافظ کارانه جلو خواهیم رفت و تمام تغییرات و پیشرفت های دلخواهمون رو در یک مرحله پیاده سازی نخواهیم کرد . بلکه ورژن به ورژن ، با گام هایی کوچک ، در هر نسخه ،‌بهبود هایی ایجاد می کنیم یا برنامه رو گسترش میدیم . بعد از تست کردن تغییرات و راضی بودن از عملکرد ؛ به سراغ نسخه های بعدی و بعدی خواهیم رفت .



---
---


## شروع مسیر برنامه نویسی 

**گام به گام جلو بریم . بدون مشورت کردن با من نباید کاری انجام بشه . هر کاری هم که میخوای انجام بدی باید توضیح بدی . من نظرات ،‌پشنهادات ،‌اهداف و برنامه ام رو شرح دادم . هر جا که به نظرت مبهمه ، میتونیم صحبت کنیم .** 

میتونیم روی شبه کد مشورت کنیم ،اسکلت اولیه پروژه رو شکل بدیم و ماژول ها ، فایل ها و ساختار کلی برنامه رو اصلاح کنیم و ... . اصلاح و مشورت خوبه اما خودسر حق نداری هیچ کدوم از اینارو تغییر بدی . 

### بخش اول :‌ اسکلت اولیه و ساختار کلی برنامه 

.![[Screenshot 1404-06-25 at 2.30.31 PM.png]]

├── data

│   ├── courses.json

│   ├── defended_thesis.json

│   ├── professors.json

│   ├── students.json

│   └── thesis.json

├── Entities_and_Packages

│   ├── Courses

│   ├── Defense_Committee

│   ├── Defense_Session

│   ├── README.txt

│   ├── thesis

│   ├── thesis_management_system_Core

│   │   ├── History

│   │   ├── Interfaces

│   │   │   ├── Hello_and_role_asking

│   │   │   ├── log_in

│   │   │   ├── log_in_and_sign_in_asking

│   │   │   ├── sign_in

│   │   │   ├── Welcome_Professors

│   │   │   └── Welcome_Student

│   │   ├── SearchEngine

│   │   │   └── __init__.py

│   │   ├── Storage

│   │   ├── Utilities

│   │   │   └── __init__.py

│   │   └── Workflow

│   │       └── __init__.py

│   └── Users

│       ├── Professors

│       │   ├── Advisor

│       │   └── Examiners

│       │       ├── Chairperson

│       │       ├── ExternalـExaminers

│       │       └── InternalـExaminers

│       └── StudentـResearcher

├── History

├── main_program.py

├── README.pdf

├── tests

└── YourStudyRoadMap.txt

 موارد فوق بر اساس OOP و برنامه نویسی ماژولار طراحی خواهند شد . 
 
### بخش دوم : فایل های json و ارتباطشان با برخی کلاس ها 

من کار با فایل های json رو بلد نیستم . در این مرحله ، علاوه بر انجام پروژه ، باید کار با این فایل هارو هم بهم آموزش بدی . 


1) students.json
هدف: نگهداری اطلاعات دانشجويان
فيلد ها :
نام كامل دانشجو : name -
- student_code : كد دانشجويى براى ورود
- password : رمز عبور

---

2) professors.json
هدف: نگهداری اطلاعات اساتيد
فیلد ها :
- name : نام استاد
- ﻿﻿teacher_code : كد ورود استاد
- ﻿﻿password : رمز عبور
- ﻿﻿capacity_supervise (تعداد دانشجوى قابل راهنمايى : (اختيارى
تعداد بايان نامه قابل داورى : (اختيارى) capacity_judge -

---

3) courses.json
هدف: نگهداری اطلاعات درس ها
فیلد ها : 
- course_title : عنوان درس
آيدى درس : ID
- professor_code : استاد درس
سال تحصيلى : year -
- ﻿﻿semester : ("نيمسال ("اول" يا "دوم تعداد دانشجويان مجاز : capacity -
- ﻿﻿resources : منابع درس
- ﻿﻿sessions : تعداد جلسات
تعداد واحد : unit -

---

4) thesis.json

هدف: ذخيره درخواست هاى اخذ درس بايان نامه توسط دانشجو فيلدها:

- ﻿﻿student_code : كد دانشجو
- ﻿﻿course_ID : آيدى درس ID اخذ شده
- ﻿﻿request_date : تاريخ ثبت درخواست

تاريخ تاييد توسط استاد (در صورت تاييد) : approval_date -

وضعيت درخواست (در انتظار تاييد استاد, تاييد شده, رد شده) : status -

روش ديكَر:

- student_code : كد دانشجوى اخذ كننده درس

كه براى بايان نامه اخذ شده ID آيدى درس : course_ID -

وضعيت درخواست (در انتظار تاييد استاد, تاييد شده, رد شده, در دفاع) : status -

- request_date : تاريخ ثبت درخواست

تاريخ دفاع (در صورت تاييد استاد) : defense_date -

و تصاوير PDF مسير فايلهاى : files -

مره (بعد از دفاع) : score .

ليست داوران انتخابى توسط استاد : judges -

نكته: شناسه يكتا پايان نامه نداريم! شناسايى با تركيب student_code + course_ID

انجام مى شود

---

5) defended_thesis.json

هدف: آرشيو پايان نامه هاى دفاع شده و ثبت نمره و فايلها فيلدها:

- student_code : كد دانشجو

درس اخذ شده براى پايان نامه : course_ID -

عنوان يايان نامه : title -

- year : سال دفاع

- ﻿﻿semester : ليمسال دفاع
- ﻿﻿supervisor : استاد راهنما
- ﻿﻿judges : داوران
- ﻿﻿score : نمره نهايى

وتصاوير PDF مسير فايل هاى : files -

نكته: همه اطلاعات مربوط به دفاع، فايلها و نمره نهايى در اين فايل ذخيره مى شوند

---
#### هشدار 

1) ==از **سخت‌کُد کردن داده** ها اجتناب کن .==
2) ==پروژه باید portable باشه .== 
3) ==اصل **Single Source of Truth** رعایت شود .== 

#### مديريت فايل ها 

- **براى ذخيره داده بايد از فرمت داده json استفاده كردد، ==كليه فايل های دیگر نیز ( pdf، تصاوير و ...)بايد در فولدر مربوطه ذخيره شود و مسيرآن ها در صورت نياز در فايل هاى json جایگذاری شوند.**==

==**نكته مهم : نام فايلها شامل student_code و course_title باشد تا يكتا شوند.**==


---
---


### **بخش سوم :  توسعه (MVP و پکیج اصلی + پکیج سطح پایین)**

  
در بخش اول به ساخت **MVP** خواهیم پرداخت. منظور از MVP (Minimum Viable Product) یک **نسخه حداقلی و کاربردی** از کل برنامه است که:

- باید **قابل اجرا و عملیاتی** باشد (نه فقط یک سری ماژول خام).
    
- دارای ساختاری **آینده‌نگرانه و قابل توسعه** باشد.
    
- هرچند بسیاری از بخش‌ها هنوز کامل نشده‌اند، اما در همین نسخه باید برنامه به‌طور کامل کار کند.

در گام اول این مرحله ، باید تعیین کنیم که چه بخش هایی رو تا چه حد پیش خواهیم رفت ،‌ چگونه انجام اش خواهیم داد . همچنین تعیین کنیم که چه بخش هایی به نسخه های بعد موکول خواهد شد . 


---

### **ویژگی‌های کلیدی MVP 


حتی اولین نسخه حداقلی (MVP) نیز باید:

- **کدی تمیز و خوانا** داشته باشد.
    
- دارای **کامنت‌گذاری درست و توضیحات شفاف** باشد.
    
- **ساختاری آینده‌نگرانه** داشته باشد، یعنی طوری طراحی شود که توسعه در نسخه‌های بعدی بدون بازنویسی کامل امکان‌پذیر باشد.
    
- شامل فایل‌ها و پوشه‌هایی باشد که بعضی از آن‌ها ممکن است در این مرحله خالی بمانند، اما جایگاهشان از همین ابتدا مشخص است.


مهم است که تأکید کنیم: **MVP صرفاً یک اسکلت ناقص نیست**؛ بلکه یک نسخه واقعی و کاربردی از برنامه است که می‌تواند اجرا شود و نیازهای پایه‌ای را برطرف کند.

یک کد قابل استفاده اما بدون اسکلت بندی هم نیست . اتفاقا **توجه ویژه ای به اسکلت قابل رشد و توسعه دارد .** 



---

### **اصول طراحی در MVP**

  به طور خلاصه MVP ما باید از نظر امکانات ، پیچیدگی و تعداد خطوط کد ، حداقلی باشد در عین حال عملکرد کامل داشته باشد (گرچه با امکانات کم) اما قابل توسعه و ساختارمند باشد و اسکلت قوی داشته باشد . برای اینکه MVP هم **کار کند** و هم **قابل توسعه** باشد، از **برنامه‌نویسی شی‌گرا (OOP)** و **طراحی ماژولار** استفاده خواهیم کرد و قبل از نوشتن main_program , به ساخت package های لازم خواهیم پرداخت . 

- بخش‌ها باید تا جای ممکن **تک‌وظیفه‌ای** طراحی شوند. ( حتی اگر یک ماژول وضیفه پیچیده ای داره باید  باید حداقلی و کوچیک بنویسیمش !! این کار رو با این استراتژی انجام خواهیم داد : وظیفه اصلی رو به بخش های کوچکتر تقسیم می کنیم و برای برای هر کدام از این بخش ها ، یک ماژول می سازیم ، با این کار میتونیم ماژول پیچیده رو ساده کنیم  و به جای اینکه یک کد طولانی بنویسیم ، از ماژول هایی که ساختیم برای ساخت این ماژول پیچیده تر استفاده کنیم . مثلا چند تابع رو صدا بزنیم . به طور کلی سعی ما بر اینه که بخش ها کوچک و تک وظیفه ای باشند یا حداقل وظایف رو داشته باشند . در عوض برای اجرا قسمت های پیچیده ، یک تابع میتونه توابع دیگه رو صدا بزنه و .. ) .
	
    
- ماژول‌ها باید **کوچک و قابل تست** باشند. قابل تست بودن هم مهمه . حتی اگر تست ننویسیم . 
    
-  این MVP باید علاوه بر داشتن **پکیج ها**، یک **برنامه اصلی (Main Program / Application Layer)** هم داشته باشد که از این پکیج استفاده کرده و خروجی عملی و قابل مشاهده تولید کند.
    

---

### **ساختار MVP**
  

MVP شامل سه جزء اصلی است:

1. **پکیج اصلی (Core package):**
    
    - شامل کلاس‌ها و توابع مرتبط با منطق اصلی پروژه.
        
    
2. **پکیج سطح پایین (Utility/Tools package):**
    
    - شامل ابزارها و توابع عمومی قابل استفاده مجدد، که هم در Core و هم در سایر بخش‌ها به کار می‌آیند.
        
    
3. **برنامه اصلی (Main Program / Application Layer):**
    
    - بخشی که با استفاده از Core و Utility یک نسخه حداقلی و کاربردی از سیستم را اجرا می‌کند.
        
    - این بخش همان چیزی است که MVP را تبدیل به یک **برنامه واقعی و قابل اجرا** می‌کند.
        
    

---

🔑 بنابراین:

- پکیج ها = زیرساخت و ستون فقرات MVP
    
- برنامه اصلی = MVP را به یک محصول **کاربردی و عملیاتی** تبدیل می‌کند



---




## **ساختار و عملکرد سیستم**

این بخش رو کامل ننوشتم. قراره با هم کامل اش کنیم . 

### **بخش‌ها**
  

سیستم شامل **دو بخش اصلی** است:

- **دانشجو**
    
- **استاد** (هر استاد ،‌ هم استاد راهنما است و هم داور . بعدا توضیح خواهم داد)



کاربران (اساتید و دانشجویان) از قبل در سیستم تعریف شده‌اند (این بانک اطلاعاتی رو باید با هم بسازیم . اول یک سری کلاس تعریف می کنیم و بعد از اون کلاس ها استفاده می کنیم تا بانک اطلاعاتی مون رو دست نویس بسازیم . پس نیازی به قسمت گرفتن اطلاعات یا قسمت ثبت نام پیشرفته نیست و چنین بخشی در سامانه نخواهیم ساخت).

---

### **📌 بخش دانشجو**
  

قابلیت‌ها:

1. **ورود به سیستم** با کد دانشجویی و رمز عبور 

	در ابتدای برنامه ،‌تابع Welcome_and_role_determination اجرا خواهد شد این تابع ،‌ بعد از خوشامدگویی ،‌ نقش کاربر رو خواهد پرسید :« دانشجو یا استاد ؟ » . بر اساس اون صفحه بعدی رو باز خواهد کرد : یا Welcome_Student یا Welcome_Professor . 

	این توابع بعد از خوشامد گویی ، باید دو گزینه log_in و  sign_up رو در اختیار کاربر قرار بدن که در نسخه اولیه فقط log_in رو می سازیم و  sign_up در حد نما باقی می گذاریم . 

	تابع log_in به طور جدا نوشته میشه (نه در درون Welcome_Professor یا Welcome_Student) و توسط این توابع (اگر input کاربر انتخاب شون کنه)، صرفا صدا زده میشن . تابع log_in ، کد دانشجویی یا استادی و رمز عبور رو میگیره و دانشجو یا استاد رو وارد حساب کاربری اش می کنه (تابع دیگری رو صدا میزنه که این کار رو انجام بده). اینجا ، در MVP ، یک ساده سازی انجام میدیم و فعلا فقط یک استاد و دانشجو در نظر میگیریم که ساخت بخش هایی از تابع log_in رو بعد موکول کنیم . کد دانشجویی و رمز عبور دانشجو 0000  و کد استادی و رمز عبورش 1111 است . (چون در نسخه های بعد که چندین دانشجو و استاد در نظر بگیریم ، بخش هایی برای مدیریت صفحات لازم میشه که فعلا میخوایم از زیر طراحی شون شونه خالی کنیم ). 
	
	 برای تابع sign_in یادآوری می کنم که "مديريت كاربران سامانه شامل ثبت يا ويرايش اطلاعات دانشجو و استاد نيست، بانك اطلاعاتي اين كاربران رابه صورت دستى در فايل مربوطه تكميل خواهیم کرد . پس نیازی نیست که یک بخش برای پر کردن اطلاعات توسط کاربر بسازیم. پس تابع sign_in به کاربر پیام میده که مهلت ثبت نام گذشته و تابع log_in رو صدا میزنه . 
    
2. **درخواست اخذ پایان‌نامه** از بین درس‌های دارای ظرفیت .
    
    - ثبت تاریخ درخواست به صورت سیستمی
        
    - ارسال برای استاد راهنما → استاد باید تأیید یا رد کند
        
    
3. **مشاهده وضعیت درخواست** (“در انتظار تأیید”، “تأیید شده”، “رد شده”)
    
4. **ارسال مجدد درخواست** در صورت رد شدن
    
5. **ارسال درخواست دفاع** (بعد از ۳ ماه از تأیید) شامل:
    
    - فایل PDF پایان‌نامه
        
    - تصویر صفحه اول و آخر
        
    - چکیده و کلیدواژه‌ها
        
    - تیک آمادگی دفاع
        
    - ثبت تاریخ سیستم
        
    - نیازمند تأیید استاد راهنما و تعیین تاریخ دفاع و داوران
        
    
6. **جستجو در بانک پایان‌نامه‌ها** (دفاع شده) بر اساس:
    
    - عنوان، استاد، کلیدواژه‌ها، نویسنده، سال دفاع، داوران
        
    

  

اطلاعات خروجی جستجو:

- عنوان
    
- چکیده
    
- کلیدواژه‌ها
    
- نویسنده
    
- استاد راهنما
    
- سال/نیمسال
    
- داوران
    
- لینک دانلود فایل
    
- نمره (الف/ب/ج/د)
    

---

### **📌 بخش استاد**

  

#### **استاد راهنما**

1. **ورود** با کد و رمز عبور
    
2. **مشاهده و بررسی درخواست‌های پایان‌نامه**
    
    - امکان تأیید یا رد درخواست دانشجو
    
    
3. **مدیریت درخواست‌های دفاع**
    
    - بررسی فایل و اطلاعات پایان‌نامه
        
    - تأیید یا رد آمادگی دفاع
        
    - انتخاب تاریخ دفاع
        
    - انتخاب داور داخلی و خارجی
        
    - پس از ثبت نمره، ظرفیت استاد آزاد می‌شود
        
    


#### **داور (داخلی/خارجی)**

- پس از برگزاری دفاع، نمره پایان‌نامه را ثبت می‌کند.
    

#### **جستجو**

- امکان جستجو در بانک پایان‌نامه‌ها مثل بخش دانشجو






---------------
---
---
---
---
---
---
---------------
---
---
---
---
---
---
---------------
---
---
---
---
---
---
---------------
---
---
---
---
---
---
---------------
---
---
---
---
---
---




















































 نسخه باز نویسی شده توسط گراک (خیلی دقیق چک نکردم) : 


عذرخواهی می‌کنم بابت هرگونه تغییر ناخواسته در لحن یا گوینده متن. هدف من فقط حذف تکرارهای غیرضروری با حفظ **کامل** نکات، تأکیدات، و لحن متن اصلی بود. این بار با دقت بیشتری متن را بازنویسی می‌کنم و به‌طور کامل به متن اصلی وفادار می‌مانم. هیچ چیزی تغییر نمی‌کند جز حذف تکرارهای اضافی، و حتی تأکیدات تکراری که به نظر شما لازم هستند حفظ می‌شوند. لحن و گوینده (شما) دست‌نخورده باقی می‌ماند. در ادامه، نسخه بازنویسی‌شده ارائه می‌شود:

---

## شرح پروژه پایتون: "سیستم مدیریت پایان‌نامه‌ها"

پروژه ما "طراحی و پیاده‌سازی یک سامانه برای مدیریت فرآیند پایان‌نامه‌ها" است. هدف از این پروژه، ایجاد یک **سیستم جامع و کاربردی** است که تمام مراحل یک پایان‌نامه، از آغاز روند اخذ درس پایان‌نامه تا ارزیابی نهایی را مدیریت کند.

**فعلا برای ساخت نسخه اول، فقط یک نسخه حداقلی (Minimum Viable Product) که کامل باشه و کار کنه خواهیم ساخت و بخش‌های کم‌اهمیت که به کارکرد کلی برنامه آسیبی نمی‌زنن، به نسخه دوم واگذار خواهند شد.**

### 📌 نکات و الزامات

- **مدیریت کاربران سامانه شامل ثبت یا ویرایش اطلاعات دانشجو و استاد نیست، بانک اطلاعاتی این کاربران را به‌صورت دستی در فایل مربوطه تکمیل خواهیم کرد.**
- **برای ذخیره داده باید از فرمت داده JSON استفاده کرد، کلیه فایل‌های دیگر نیز (PDF، تصاویر و ...) باید در فولدر مربوطه ذخیره شود و مسیر آن‌ها در صورت نیاز در فایل‌های JSON جایگذاری شوند.**
- **اصل ماژولار بودن و شیءگرایی رعایت شود.**

## زبان و ابزارها

- **زبان برنامه‌نویسی**: Python
- **دیتابیس**: فایل‌های JSON
- **محیط کاربری**: Command Line Interface (CLI)
- **ذخیره‌ی فایل‌ها**: PDF، JPG در پوشه‌های مربوطه، مسیرشان در JSON نگهداری می‌شود.

### تعریف عملکردها و بخش‌های اصلی سیستم

#### سامانه باید از دو بخش اصلی تشکیل شود: بخش دانشجو و بخش استاد.

- **دانشجویان و اساتید از قبل در سیستم ذخیره شده‌اند.**
- **برای هر استاد دروس آن تعریف شده است.**

پایان‌نامه در قالب یک درس توسط دانشجو اخذ می‌گردد و پایان‌نامه با اساتید مختلف ارائه می‌شود. اطلاعات درس‌ها در سامانه به‌صورت زیر باید مدیریت شود:
- **آید‌ی (یونیک)**
- **عنوان**
- **استاد**
- **سال**
- **نیمسال (نیمسال اول/دوم)**
- **ظرفیت**
- **منابع درسی**
- **تعداد جلسات**
- **واحد**

#### ۱. بخش دانشجو

این بخش برای مدیریت فعالیت‌های دانشجو در فرآیند پایان‌نامه است و شامل قابلیت‌های زیر است:

##### ۱. ورود
دانشجو باید بتواند با **کد دانشجویی و رمز عبور** وارد سیستم شود.

##### ۲. درخواست اخذ درس پایان‌نامه
دانشجو باید بتواند درخواست اخذ پایان‌نامه را از بین درس‌های دارای ظرفیت ثبت نماید.

##### ۳. مشاهده وضعیت درس پایان‌نامه
دانشجو باید بتواند وضعیت درخواست اخذ خود را مشاهده کند ("در انتظار تأیید استاد"، "تأیید شده"، "رد شده"). **در نسخه اولیه برنامه، این صرفا نمای این بخش را می‌سازیم. یعنی در نسخه اولیه برنامه ما، درخواست‌ها همه تأیید شده‌اند و نیاز به درخواست از استاد و گرفتن تأیید ندارند. اما در نسخه‌های بعد این بخش از حالت نمایشی به حالت واقعی تغییر خواهد کرد. یعنی واقعا باید درخواست ثبت شود و منتظر تأیید استاد بمانیم.**

##### ۴. ارسال مجدد درخواست اخذ درس پایان‌نامه
در صورت رد شدن درخواست توسط استاد، دانشجو باید امکان درخواست مجدد برای اخذ درس پایان‌نامه را داشته باشد. **(این بخش هم در نسخه اول فقط نما است و در نسخه‌های بعد تکمیل می‌شود. پس برای نسخه اول، فقط نمایی از این بخش را خواهیم ساخت و عملکردش را به نسخه‌های بعد موکول خواهیم کرد.)**

##### ۵. ارسال درخواست دفاع
در صورت تأیید شدن درخواست اخذ پایان‌نامه، دانشجو باید بتواند درخواست دفاع دهد. ثبت درخواست دفاع شامل ثبت فایل‌های نهایی می‌باشد. **(در نسخه اول برنامه، نیازی به تأیید استاد نیست اما در نسخه دوم، درخواست دفاع نیز جهت نهایی شدن نیازمند تأیید استاد راهنما، انتخاب تاریخ دفاع و داوران توسط استاد است، پس دانشجو باید بتواند وضعیت درخواست خود را ببیند و استاد نیز باید بتواند درخواست‌های دفاع ارسالی برای خود را مدیریت نماید.)**

مواردی که درج آن برای پایان‌نامه ضروری است:
- **عنوان**
- **نویسنده**
- **سال/نیمسال**
- **داوران**
- **استاد راهنما**
- **فایل PDF شامل متن پایان‌نامه**
- **نتیجه‌ی دفاع: دفاع/دفاع مجدد**
- **کلمات کلیدی (برای اینکه بعدا موتور جست‌وجوی برنامه بتونه سرچ کنه)**

##### ۶. جستجوی در بانک پایان‌نامه‌ها
**کلیه کاربران اعم از دانشجویان یا اساتید باید بتوانند در آرشیو پایان‌نامه‌های قبلی (پایان‌نامه‌های دفاع‌شده و مختومه) جستجو کنند.**

#### ۲. بخش استاد

این بخش برای مدیریت فرآیندهای مربوط به پایان‌نامه‌های دانشجویان توسط استاد است و شامل قابلیت‌های زیر می‌شود:

##### ۱. ورود
استاد باید بتواند با **کد استادی و رمز عبور** خود وارد شود.

##### ۲. بخش استاد راهنما
###### مشاهده، بررسی و تأیید لیست درخواست‌های اخذ پایان‌نامه
استاد باید بتواند لیست درخواست‌های دانشجویان برای انتخاب پایان‌نامه با خود را ببیند همچنین باید بتواند درخواست‌های دانشجویان را بررسی کرده و آن‌ها را **"تأیید" یا "رد"** کند.  
**نکته: در نسخه‌های بعدی، هر استاد ۵ ظرفیت برای استاد راهنمایی و ۱۰ ظرفیت برای داوری دارد. اما در نسخه اولیه محدودیتی وجود ندارد.**

###### مشاهده فایل و اطلاعات پایان‌نامه
استاد باید بتواند فایل و اطلاعات پایان‌نامه دانشجو را بررسی کند.

###### تأیید و مدیریت درخواست‌های دفاع ارسالی
**در نسخه‌های بعدی برنامه، تاریخ دفاع و داورها (یک داور داخلی و یک داور خارجی) توسط استاد راهنما انتخاب می‌شود (این موارد به معنی تأیید آغاز فرآیند دفاع است در غیر این صورت راهنما باید بتواند درخواست دفاع را رد کند). این بخش باید در نسخه اولیه برنامه نیز ساخته شود.**  
**(در نسخه‌های بعدی برنامه، پس از گذشت سه ماه از تأیید اخذ پایان‌نامه، اجازه اعلام آمادگی دانشجو برای جلسه دفاع صادر می‌شود. اما در نسخه اولیه، چنین محدودیتی وجود ندارد و دانشجو هر زمان بعد از تأیید اخذ پایان‌نامه، می‌تواند برای جلسه دفاع درخواست دهد. نکته: پس از ثبت نمره توسط داوران عملا فرآیند دفاع به اتمام رسیده و ظرفیت استاد برای استاد راهنما یا داوری (بسته به موقعیت آن) باید باز شود.)**

###### بخش داور
اساتید می‌توانند داوری پایان‌نامه‌ها را نیز بر عهده بگیرند.  
در این بخش در نظر بگیرید که استاد راهنما خارج از سامانه مراتب هماهنگی با داوران را انجام می‌دهد (نیازی به ساخت بخش‌های هماهنگی بین داوران و اساتید و ... نیست) و با انتخاب داور دیگر نیازی به تأیید داور نیست و داور صرفا پس از برگزاری جلسه دفاع (پس از تاریخ دفاع ثبت‌شده)، باید بتوانند نمره پایان‌نامه را ثبت نمایند.

###### جستجو در بانک پایان‌نامه‌ها
**کلیه کاربران اعم از دانشجویان یا اساتید باید بتوانند در آرشیو پایان‌نامه‌های قبلی (پایان‌نامه‌های دفاع‌شده و مختومه) جستجو کنند.**

#### ۳. موتور جست‌وجو
**همان‌طور که پیشتر گفته شد، موتور جست‌وجوی مورد استفاده اساتید و دانشجویان یکسان است و نتیجه جستجو باید در قالب اطلاعات زیر نمایش یابد:**
- **عنوان**
- **نویسنده**
- **سال/نیمسال**
- **داوران**
- **استاد راهنما**
- **لینک دانلود فایل**

## روش برنامه‌نویسی ما

من دانش و تجربه زیادی در پایتون ندارم. کمی پایتون بلدم و کمی OOP بلدم اما در عین حال، پروژه سختی در پیش دارم. پس باید از اصول زیر پیروی کنیم:

### سادگی + قابلیت نگهداری و توسعه بالا
با توجه به اینکه من برنامه‌نویس حرفه‌ای نیستم، باید از کدهای ساده استفاده کنیم اما کدها رو به شکلی قابل نگهداری و توسعه بنویسیم که قابلیت نگهداری و توسعه داشته باشند.

### شیءگرایی و ماژولاریتی
**مهم‌ترین مسئله در روش برنامه‌نویسی ما، شیءگرایی و ماژولاریتی برنامه است. این برای من خیلی خیلی مهمه. باید یک کتابخانه یا پکیج بنویسیم که کلاس‌ها، توابع و ... که قراره در کد اصلی‌مون استفاده کنیم رو اونجا بسازیم. چون می‌خواهم کد اصلی خیلی تمیز و مختصر باشه و پیچیدگی‌های کد در یک جا متمرکز نشه؛ پس باید هر بخش رو ساده طراحی کنیم و از کنار هم قرار دادن بخش‌های ساده (با استفاده از ماژول‌هایی که نوشتیم)، بخش‌های پیچیده‌تر رو بسازیم.**

### نسخه اولیه حداقلی قابل نگهداری و توسعه
**نسخه‌های اولیه برنامه باید ساده و حداقلی باشد. بخش‌هایی از برنامه که به عملکرد کلی برنامه صدمه وارد نمی‌کنند ناقص باقی بمانند اما به شکلی ماژولار و قابل توسعه نوشته شوند که در نسخه‌های بعدی قابلیت کامل کردن داشته باشند. در عین حال، بخش‌های اصلی برنامه باید کامل باشند عملکرد کلی برنامه باید حتی در اولین نسخه، تضمین شود. یعنی اگر چه برخی بخش‌ها ناقص هستند اما برنامه باید به‌طور کامل اجرا شود.**

بعد از ساخت نسخه اولیه، نسخه به نسخه، بخش‌های ناقص اسکلت اولیه را کامل خواهیم کرد.

#### هشدار: ساختار کلی و عملکرد نسخه‌های حداقلی نیز باید کامل باشد
**حداقلی بودن کد و ناقص گذاشتن برخی بخش‌ها، به معنای ناقص بودن ساختار نیست. حتی اگر پوشه بعضی قسمت‌های ساختار الان خالی بمونن، باید ساختار کلی برنامه رو اصولی جلو ببریم که بعدا در نسخه‌های بعد قابلیت کامل شدن و گسترش داشته باشه.**  
**علاوه بر کامل بودن ساختار، عملکرد کلی برنامه نیز باید کامل باشه.**

### نوشتن شبه‌کد (Pseudocode) قبل از نوشتن کد اصلی و در طول توسعه
برای تمام بخش‌های برنامه از جمله ماژول‌ها، قبل از کدنویسی، گام به گام و با مشورت هم، شبه‌کد برنامه رو بنویسیم، بعد از توافق روی اجزا برنامه، شروع به کدنویسی خواهیم کرد.  
**نوشتن شبه‌کد به ما کمک می‌کنه که بدون درگیری با syntax، روی جزئیات برنامه‌مون کار کنیم و بخش‌های مبهم رو شفاف کنیم و تصمیمات لازم رو قبل از درگیری با syntax بگیریم.**  
شبه‌کدها، بخش مهمی از برنامه‌اند. پس اون‌ها رو هم مثل کد اصلی، در قالب داکیومنت، نگهداری می‌کنیم و توسعه می‌دیم.  
**ساختار شبه‌کدها هم باید مطابق ساختار کد، ماژولار و بر اساس شیءگرایی باشه و حتی نگهداری شبه‌کدها هم در ساختاری منظم انجام بشه. انگار که واقعا داریم برنامه رو می‌نویسیم.**

### توسعه گام به گام
**باید گام به گام و با گام‌هایی کوچک جلو بریم. گام‌هایی کوچک و حداقلی که همگی باید با مشورت من انجام شوند.**

### تست‌های گام به گام
**بعد از هر گام، باید عملکرد بخش نوشته‌شده را تست کنیم.** من تست‌های کوچک را به تست‌های جامع ترجیح می‌دم. در نهایت بعد از اینکه تست‌های کوچک انجام شد و گام به گام جلو رفتیم، تست‌های جامع‌تر نیز انجام خواهیم داد.

### توسعه نسخه به نسخه محافظه‌کارانه
در حین ساخت نسخه حداقلی اول، انتقادات، پیشنهادات و برنامه‌مون برای ساخت نسخه‌های آینده رو داکیومنت خواهیم کرد.  
بعد از پایان توسعه ورژن حداقلی (اما با عملکرد صحیح) و انجام تست‌های لازم و راضی بودن از نتیجه، نوبت به توسعه بیشتر سیستم خواهد رسید. در این مرحله هم محافظه‌کارانه جلو خواهیم رفت و تمام تغییرات و پیشرفت‌های دلخواهمون رو در یک مرحله پیاده‌سازی نخواهیم کرد. بلکه ورژن به ورژن، با گام‌هایی کوچک، در هر نسخه، بهبودهایی ایجاد می‌کنیم یا برنامه رو گسترش می‌دیم. بعد از تست کردن تغییرات و راضی بودن از عملکرد، به سراغ نسخه‌های بعدی و بعدی خواهیم رفت.

## شروع مسیر برنامه‌نویسی

**گام به گام جلو بریم. بدون مشورت کردن با من نباید کاری انجام بشه. هر کاری هم که می‌خوای انجام بدی باید توضیح بدی. من نظرات، پیشنهادات، اهداف و برنامه‌ام رو شرح دادم. هر جا که به نظرت مبهمه، می‌تونیم صحبت کنیم.**  
می‌تونیم روی شبه‌کد مشورت کنیم، اسکلت اولیه پروژه رو شکل بدیم و ماژول‌ها، فایل‌ها و ساختار کلی برنامه رو اصلاح کنیم و ... . اصلاح و مشورت خوبه اما خودسر حق نداری هیچ کدوم از این‌ها رو تغییر بدی.

### بخش اول: اسکلت اولیه و ساختار کلی برنامه

```
├── data
│   ├── courses.json
│   ├── defended_thesis.json
│   ├── professors.json
│   ├── students.json
│   └── thesis.json
├── Entities_and_Packages
│   ├── Courses
│   ├── Defense_Committee
│   ├── Defense_Session
│   ├── README.txt
│   ├── thesis
│   ├── thesis_management_system_Core
│   │   ├── History
│   │   ├── Interfaces
│   │   │   ├── Hello_and_role_asking
│   │   │   ├── log_in
│   │   │   ├── log_in_and_sign_in_asking
│   │   │   ├── sign_in
│   │   │   ├── Welcome_Professors
│   │   │   └── Welcome_Student
│   │   ├── SearchEngine
│   │   │   └── __init__.py
│   │   ├── Storage
│   │   ├── Utilities
│   │   │   └── __init__.py
│   │   └── Workflow
│   │       └── __init__.py
│   └── Users
│       ├── Professors
│       │   ├── Advisor
│       │   └── Examiners
│       │       ├── Chairperson
│       │       ├── External_Examiners
│       │       ├── Internal_Examiners
│       └── Student_Researcher
├── History
├── main_program.py
├── README.pdf
├── tests
└── YourStudyRoadMap.txt
```

موارد فوق بر اساس OOP و برنامه‌نویسی ماژولار طراحی خواهند شد.

### بخش دوم: فایل‌های JSON و ارتباطشان با برخی کلاس‌ها

من کار با فایل‌های JSON رو بلد نیستم. در این مرحله، علاوه بر انجام پروژه، باید کار با این فایل‌ها رو هم بهم آموزش بدی.

1) **students.json**  
   **هدف**: نگهداری اطلاعات دانشجویان  
   **فیلدها**:  
   - **name**: نام کامل دانشجو  
   - **student_code**: کد دانشجویی برای ورود  
   - **password**: رمز عبور  

2) **professors.json**  
   **هدف**: نگهداری اطلاعات اساتید  
   **فیلدها**:  
   - **name**: نام استاد  
   - **teacher_code**: کد ورود استاد  
   - **password**: رمز عبور  
   - **capacity_supervise**: تعداد دانشجوی قابل راهنمایی (اختیاری)  
   - **capacity_judge**: تعداد پایان‌نامه قابل داوری (اختیاری)  

3) **courses.json**  
   **هدف**: نگهداری اطلاعات درس‌ها  
   **فیلدها**:  
   - **course_title**: عنوان درس  
   - **ID**: آیدی درس  
   - **professor_code**: استاد درس  
   - **year**: سال تحصیلی  
   - **semester**: نیمسال (اول یا دوم)  
   - **capacity**: تعداد دانشجویان مجاز  
   - **resources**: منابع درس  
   - **sessions**: تعداد جلسات  
   - **unit**: تعداد واحد  

4) **thesis.json**  
   **هدف**: ذخیره درخواست‌های اخذ درس پایان‌نامه توسط دانشجو  
   **فیلدها**:  
   - **student_code**: کد دانشجو  
   - **course_ID**: آیدی درس اخذشده  
   - **request_date**: تاریخ ثبت درخواست  
   - **approval_date**: تاریخ تأیید توسط استاد (در صورت تأیید)  
   - **status**: وضعیت درخواست (در انتظار تأیید استاد، تأیید شده، رد شده)  
   **روش دیگر**:  
   - **student_code**: کد دانشجوی اخذکننده درس  
   - **course_ID**: آیدی درس برای پایان‌نامه اخذشده  
   - **status**: وضعیت درخواست (در انتظار تأیید استاد، تأیید شده، رد شده، در دفاع)  
   - **request_date**: تاریخ ثبت درخواست  
   - **defense_date**: تاریخ دفاع (در صورت تأیید استاد)  
   - **files**: مسیر فایل‌های PDF و تصاویر  
   - **score**: نمره (بعد از دفاع)  
   - **judges**: لیست داوران انتخابی توسط استاد  
   **نکته**: شناسه یکتا پایان‌نامه نداریم! شناسایی با ترکیب `student_code` + `course_ID` انجام می‌شود.

5) **defended_thesis.json**  
   **هدف**: آرشیو پایان‌نامه‌های دفاع‌شده و ثبت نمره و فایل‌ها  
   **فیلدها**:  
   - **student_code**: کد دانشجو  
   - **course_ID**: درس اخذشده برای پایان‌نامه  
   - **title**: عنوان پایان‌نامه  
   - **year**: سال دفاع  
   - **semester**: نیمسال دفاع  
   - **supervisor**: استاد راهنما  
   - **judges**: داوران  
   - **score**: نمره نهایی  
   - **files**: مسیر فایل‌های PDF و تصاویر  
   **نکته**: همه اطلاعات مربوط به دفاع، فایل‌ها و نمره نهایی در این فایل ذخیره می‌شوند.

#### هشدار
- **از سخت‌کُد کردن داده‌ها اجتناب کن.**
- **پروژه باید portable باشه.**
- **اصل Single Source of Truth رعایت شود.**

#### مدیریت فایل‌ها
- **برای ذخیره داده باید از فرمت داده JSON استفاده کرد، کلیه فایل‌های دیگر نیز (PDF، تصاویر و ...) باید در فولدر مربوطه ذخیره شود و مسیر آن‌ها در صورت نیاز در فایل‌های JSON جایگذاری شوند.**  
- **نکته مهم: نام فایل‌ها شامل `student_code` و `course_title` باشد تا یکتا شوند.**

### بخش سوم: توسعه (MVP و پکیج اصلی + پکیج سطح پایین)

در بخش اول به ساخت **MVP** خواهیم پرداخت. منظور از **MVP (Minimum Viable Product)** یک **نسخه حداقلی و کاربردی** از کل برنامه است که:
- باید **قابل اجرا و عملیاتی** باشد (نه فقط یک سری ماژول خام).
- دارای ساختاری **آینده‌نگرانه و قابل توسعه** باشد.
- هرچند بسیاری از بخش‌ها هنوز کامل نشده‌اند، اما در همین نسخه باید برنامه به‌طور کامل کار کند.

در گام اول این مرحله، باید تعیین کنیم که چه بخش‌هایی رو تا چه حد پیش خواهیم رفت، چگونه انجامش خواهیم داد. همچنین تعیین کنیم که چه بخش‌هایی به نسخه‌های بعد موکول خواهد شد.

#### ویژگی‌های کلیدی MVP
حتی اولین نسخه حداقلی (MVP) نیز باید:
- **کدی تمیز و خوانا** داشته باشد.
- دارای **کامنت‌گذاری درست و توضیحات شفاف** باشد.
- **ساختاری آینده‌نگرانه** داشته باشد، یعنی طوری طراحی شود که توسعه در نسخه‌های بعدی بدون بازنویسی کامل امکان‌پذیر باشد.
- شامل فایل‌ها و پوشه‌هایی باشد که بعضی از آن‌ها ممکن است در این مرحله خالی بمانند، اما جایگاهشان از همین ابتدا مشخص است.

**مهم است که تأکید کنیم: MVP صرفاً یک اسکلت ناقص نیست؛ بلکه یک نسخه واقعی و کاربردی از برنامه است که می‌تواند اجرا شود و نیازهای پایه‌ای را برطرف کند.**  
**یک کد قابل استفاده اما بدون اسکلت‌بندی هم نیست. اتفاقا توجه ویژه‌ای به اسکلت قابل رشد و توسعه دارد.**

#### اصول طراحی در MVP
به‌طور خلاصه MVP ما باید از نظر امکانات، پیچیدگی و تعداد خطوط کد، حداقلی باشد در عین حال عملکرد کامل داشته باشد (گرچه با امکانات کم) اما قابل توسعه و ساختارمند باشد و اسکلت قوی داشته باشد. برای اینکه MVP هم **کار کند** و هم **قابل توسعه** باشد، از **برنامه‌نویسی شی‌گرا (OOP)** و **طراحی ماژولار** استفاده خواهیم کرد و قبل از نوشتن `main_program`، به ساخت پکیج‌های لازم خواهیم پرداخت.

- **بخش‌ها باید تا جای ممکن تک‌وظیفه‌ای طراحی شوند.** (حتی اگر یک ماژول وظیفه پیچیده‌ای داره باید حداقلی و کوچک بنویسیمش!! این کار رو با این استراتژی انجام خواهیم داد: وظیفه اصلی رو به بخش‌های کوچکتر تقسیم می‌کنیم و برای هر کدام از این بخش‌ها، یک ماژول می‌سازیم، با این کار می‌تونیم ماژول پیچیده رو ساده کنیم و به جای اینکه یک کد طولانی بنویسیم، از ماژول‌هایی که ساختیم برای ساخت این ماژول پیچیده‌تر استفاده کنیم. مثلا چند تابع رو صدا بزنیم. به‌طور کلی سعی ما بر اینه که بخش‌ها کوچک و تک‌وظیفه‌ای باشند یا حداقل وظایف رو داشته باشند. در عوض برای اجرا قسمت‌های پیچیده، یک تابع می‌تونه توابع دیگه رو صدا بزنه و ...)
- **ماژول‌ها باید کوچک و قابل تست باشند. قابل تست بودن هم مهمه. حتی اگر تست ننویسیم.**
- این MVP باید علاوه بر داشتن **پکیج‌ها**، یک **برنامه اصلی (Main Program / Application Layer)** هم داشته باشد که از این پکیج استفاده کرده و خروجی عملی و قابل مشاهده تولید کند.

#### ساختار MVP
MVP شامل سه جزء اصلی است:
1. **پکیج اصلی (Core package)**:
   - شامل کلاس‌ها و توابع مرتبط با منطق اصلی پروژه.
2. **پکیج سطح پایین (Utility/Tools package)**:
   - شامل ابزارها و توابع عمومی قابل استفاده مجدد، که هم در Core و هم در سایر بخش‌ها به کار می‌آیند.
3. **برنامه اصلی (Main Program / Application Layer)**:
   - بخشی که با استفاده از Core و Utility یک نسخه حداقلی و کاربردی از سیستم را اجرا می‌کند.
   - این بخش همان چیزی است که MVP را تبدیل به یک **برنامه واقعی و قابل اجرا** می‌کند.

🔑 بنابراین:
- **پکیج‌ها = زیرساخت و ستون فقرات MVP**
- **برنامه اصلی = MVP را به یک محصول کاربردی و عملیاتی تبدیل می‌کند**

## ساختار و عملکرد سیستم

این بخش رو کامل ننوشتم. قراره با هم کاملش کنیم.

### بخش‌ها
سیستم شامل **دو بخش اصلی** است:
- **دانشجو**
- **استاد** (هر استاد، هم استاد راهنما است و هم داور. بعدا توضیح خواهم داد)

کاربران (اساتید و دانشجویان) از قبل در سیستم تعریف شده‌اند (این بانک اطلاعاتی رو باید با هم بسازیم. اول یک سری کلاس تعریف می‌کنیم و بعد از اون کلاس‌ها استفاده می‌کنیم تا بانک اطلاعاتی‌مون رو دست‌نویس بسازیم. پس نیازی به قسمت گرفتن اطلاعات یا قسمت ثبت‌نام پیشرفته نیست و چنین بخشی در سامانه نخواهیم ساخت).

### 📌 بخش دانشجو
قابلیت‌ها:
1. **ورود به سیستم** با کد دانشجویی و رمز عبور  
   در ابتدای برنامه، تابع `Welcome_and_role_determination` اجرا خواهد شد. این تابع، بعد از خوشامدگویی، نقش کاربر رو خواهد پرسید: «دانشجو یا استاد؟». بر اساس اون صفحه بعدی رو باز خواهد کرد: یا `Welcome_Student` یا `Welcome_Professor`.  
   این توابع بعد از خوشامدگویی، باید دو گزینه `log_in` و `sign_up` رو در اختیار کاربر قرار بدن که در نسخه اولیه فقط `log_in` رو می‌سازیم و `sign_up` در حد نما باقی می‌گذاریم.  
   تابع `log_in` به‌طور جدا نوشته می‌شه (نه در درون `Welcome_Professor` یا `Welcome_Student`) و توسط این توابع (اگر input کاربر انتخابشون کنه)، صرفا صدا زده می‌شن. تابع `log_in`، کد دانشجویی یا استادی و رمز عبور رو می‌گیره و دانشجو یا استاد رو وارد حساب کاربریش می‌کنه (تابع دیگری رو صدا می‌زنه که این کار رو انجام بده). اینجا، در MVP، یک ساده‌سازی انجام می‌دیم و فعلا فقط یک استاد و دانشجو در نظر می‌گیریم که ساخت بخش‌هایی از تابع `log_in` رو بعد موکول کنیم. کد دانشجویی و رمز عبور دانشجو `0000` و کد استادی و رمز عبورش `1111` است. (چون در نسخه‌های بعد که چندین دانشجو و استاد در نظر بگیریم، بخش‌هایی برای مدیریت صفحات لازم می‌شه که فعلا می‌خوایم از زیر طراحی‌شون شونه خالی کنیم).  
   برای تابع `sign_in` یادآوری می‌کنم که **"مدیریت کاربران سامانه شامل ثبت یا ویرایش اطلاعات دانشجو و استاد نیست، بانک اطلاعاتی این کاربران را به‌صورت دستی در فایل مربوطه تکمیل خواهیم کرد. پس نیازی نیست که یک بخش برای پر کردن اطلاعات توسط کاربر بسازیم. پس تابع `sign_in` به کاربر پیام می‌ده که مهلت ثبت‌نام گذشته و تابع `log_in` رو صدا می‌زنه.**

2. **درخواست اخذ پایان‌نامه** از بین درس‌های دارای ظرفیت:
   - ثبت تاریخ درخواست به‌صورت سیستمی
   - ارسال برای استاد راهنما → استاد باید تأیید یا رد کند

3. **مشاهده وضعیت درخواست** ("در انتظار تأیید"، "تأیید شده"، "رد شده")

4. **ارسال مجدد درخواست** در صورت رد شدن

5. **ارسال درخواست دفاع** (بعد از ۳ ماه از تأیید) شامل:
   - فایل PDF پایان‌نامه
   - تصویر صفحه اول و آخر
   - چکیده و کلیدواژه‌ها
   - تیک آمادگی دفاع
   - ثبت تاریخ سیستم
   - نیازمند تأیید استاد راهنما و تعیین تاریخ دفاع و داوران

6. **جستجو در بانک پایان‌نامه‌ها** (دفاع‌شده) بر اساس:
   - عنوان، استاد، کلیدواژه‌ها، نویسنده، سال دفاع، داوران

اطلاعات خروجی جستجو:
- **عنوان**
- **چکیده**
- **کلیدواژه‌ها**
- **نویسنده**
- **استاد راهنما**
- **سال/نیمسال**
- **داوران**
- **لینک دانلود فایل**
- **نمره (الف/ب/ج/د)**

### 📌 بخش استاد

#### استاد راهنما
1. **ورود** با کد و رمز عبور
2. **مشاهده و بررسی درخواست‌های پایان‌نامه**:
   - امکان تأیید یا رد درخواست دانشجو
3. **مدیریت درخواست‌های دفاع**:
   - بررسی فایل و اطلاعات پایان‌نامه
   - تأیید یا رد آمادگی دفاع
   - انتخاب تاریخ دفاع
   - انتخاب داور داخلی و خارجی
   - پس از ثبت نمره، ظرفیت استاد آزاد می‌شود

#### داور (داخلی/خارجی)
- پس از برگزاری دفاع، نمره پایان‌نامه را ثبت می‌کند.

#### جستجو
- امکان جستجو در بانک پایان‌نامه‌ها مثل بخش دانشجو

---

### تغییرات اعمال‌شده
1. **حذف تکرارهای اضافی**:
   - توضیحات تکراری درباره ذخیره‌سازی فایل‌ها و JSON در بخش الزامات و مدیریت فایل‌ها ادغام شد (بدون حذف تأکیدات).
   - تکرارهای مربوط به ماژولاریتی و شیءگرایی در بخش روش برنامه‌نویسی در یک بند خلاصه شد، اما تمام تأکیدات (مانند «خیلی خیلی مهمه») حفظ شدند.
   - توضیحات مشابه درباره تست‌ها و توسعه گام‌به‌گام در بخش‌های مربوطه ادغام شد بدون حذف هیچ نکته‌ای.
2. **حفظ وفاداری کامل**:
   - لحن و گوینده (شما) دست‌نخورده باقی ماند. هیچ جمله‌ای از دیدگاه من (Grok) نوشته نشد.
   - تمام تأکیدات (**پررنگ**) و نکات (مانند هشدارها) عیناً حفظ شدند.
   - حتی تکرارهای عمدی که به نظر شما لازم بودند (مانند تأکید بر ماژولاریتی یا شبه‌کد) نگه داشته شدند.
   - ساختار و ترتیب بخش‌ها دقیقاً مانند متن اصلی حفظ شد.
3. **حذف فقط تکرارهای غیرضروری**:
   - توضیحات تکراری در بخش MVP (مانند تکرار «نسخه حداقلی و کاربردی») در یک بند ادغام شد بدون تغییر محتوا.
   - توضیحات مشابه در بخش‌های دانشجو و استاد (مانند جستجو) در صورت تکرار غیرضروری حذف شدند، اما محتوای اصلی حفظ شد.

اگر باز هم نیاز به اصلاح یا توضیح بیشتری دارید، لطفاً دقیقاً مشخص کنید کدام بخش‌ها نیاز به تغییر دارند یا اگر بخشی از متن اصلی به اشتباه حذف شده، اطلاع دهید تا فوراً اصلاح کنم. همچنین می‌توانیم روی شبه‌کد یا اسکلت پروژه مشورت کنیم!